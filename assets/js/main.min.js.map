{"version":3,"sources":["webpack:///main.min.js","webpack:///webpack/bootstrap 612efa4e39356f527593","webpack:///./_src/util/index.ts","webpack:///./_src/main.ts","webpack:///./_src/util/add-tooltips-to-home-icons.ts","webpack:///./_src/util/animate-header.ts","webpack:///./~/tippy.js/dist/tippy.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/tippy.js/dist/tippy.css?2a90","webpack:///./~/style-loader/lib/addStyles.js","webpack:///./~/style-loader/lib/urls.js","webpack:///./~/tippy.js/dist/tippy.js","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__export","util_1","document","addEventListener","animateHeader","addTooltipsToHomeIcons","tippy","interactive","performance","position","heading","getElementById","letters","innerHTML","split","wrappedHeading","map","letter","join","undefined","push","cssWithMappingToString","item","useSourceMap","content","cssMapping","btoa","sourceMapping","toComment","concat","sources","source","sourceRoot","sourceMap","unescape","encodeURIComponent","JSON","stringify","list","toString","this","mediaQuery","alreadyImportedModules","length","id","options","transform","locals","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","base","css","media","part","insertStyleElement","style","target","getElement","insertInto","Error","lastStyleElementInsertedAtTop","stylesInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","parentNode","removeChild","idx","indexOf","splice","createStyleElement","createElement","attrs","type","addAttrs","createLinkElement","link","rel","el","keys","forEach","key","setAttribute","obj","update","remove","result","singleton","styleIndex","singletonCounter","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","updateLink","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","autoFixUrls","convertToAbsoluteUrls","fixUrls","blob","oldSrc","isOldIE","fn","memo","apply","arguments","window","all","atob","selector","querySelector","DEBUG","newList","mayRemove","textStore","replacement","filter","Boolean","location","baseUrl","protocol","host","currentDir","pathname","replace","fullMatch","origUrl","unquotedOrigUrl","trim","$1","test","newUrl","global","factory","hideAllPoppers","currentRef","Store","ref","popper","tippyInstance","_ref$settings","settings","appendTo","hideOnClick","trigger","contains","isHideOnClick","isNotCurrentRef","hide","closest","element","parentSelector","matches","Element","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","ownerDocument","querySelectorAll","parentElement","find","arr","checkFn","Array","init","done","Defaults","body","touchHandler","Browser","touch","iOS","classList","add","dynamicInputDetection","mousemoveHandler","time","now","removeEventListener","clickHandler","event","Selectors","TOOLTIPPED_EL","POPPER","_ref","multiple","CONTROLLER","SUPPORTS_TOUCH","navigator","maxTouchPoints","msMaxTouchPoints","queueExecution","requestAnimationFrame","setTimeout","prefix","prefixes","upperProp","charAt","toUpperCase","slice","_prefix","prefixedProp","removeTitle","title","getAttribute","removeAttribute","elementIsInViewport","rect","getBoundingClientRect","top","left","bottom","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","triggerReflow","tooltip","circle","getComputedStyle","opacity","modifyClassList","els","callback","applyTransitionDuration","duration","_duration","hasAttribute","Math","round","isVisible","visibility","noop","getCorePlacement","placement","followCursorHandler","e","_this","halfPopperWidth","offsetWidth","halfPopperHeight","offsetHeight","pageWidth","pageX","pageY","x","y","isRightOverflowing","isLeftOverflowing","getArrayOfElementsFromSelector","onTransitionEnd","TOOLTIP","transitionendFired","listenerCallback","clearTimeout","_transitionendTimeout","microtaskDebounce","scheduled","elem","MutationObserver","observe","attributes","taskDebounce","timeoutDuration","isNumeric","isNaN","parseFloat","isFinite","setStyles","prop","unit","isFunction","functionToCheck","getType","getStyleComputedProperty","nodeType","getParentNode","nodeName","getScrollParent","_getStyleComputedProp","overflow","overflowX","overflowY","isOffsetContainer","firstElementChild","offsetParent","getRoot","node","getOffsetParent","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","subtract","scrollTop","scrollLeft","modifier","getBordersSize","axis","sideA","sideB","getSize","computedStyle","max","isIE10$1","getWindowSizes","height","width","getClientRect","offsets","_extends","err","sizes","horizScrollbar","vertScrollbar","getOffsetRectRelativeToArbitraryNode","children","parent","isIE10","isHTML","childrenRect","parentRect","scrollParent","marginTop","marginLeft","borderTopWidth","borderLeftWidth","getViewportOffsetRectRelativeToArtbitraryNode","relativeOffset","isFixed","getBoundaries","reference","padding","boundariesElement","boundaries","boundariesNode","_getWindowSizes","getArea","computeAutoPlacement","refRect","rects","sortedAreas","area","sort","a","b","filteredAreas","_ref2","computedPlacement","variation","getReferenceOffsets","state","getOuterSizes","marginBottom","marginRight","getOppositePlacement","hash","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find$1","check","findIndex","cur","match","runModifiers","modifiers","data","ends","function","console","warn","enabled","isDestroyed","instance","flipped","flip","originalPlacement","isCreated","onUpdate","onCreate","isModifierEnabled","modifierName","some","getSupportedPropertyName","toCheck","destroy","disableEventListeners","removeOnDestroy","attachToScrollParents","scrollParents","isBody","passive","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","cancelAnimationFrame","setAttributes","applyStyle","arrow","arrowElement","applyStyleOnLoad","modifierOptions","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","prefixedProperty","willChange","invertTop","invertLeft","x-placement","isModifierRequired","requestingName","requestedName","requesting","isRequired","_requesting","requested","_data$offsets","isVertical","len","altSide","opSide","arrowElementSize","center","sideValue","min","getOppositeVariation","clockwise","counter","validPlacements","reverse","placementOpposite","flipOrder","behavior","BEHAVIORS","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","floor","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","toValue","str","parseOffset","offset","basePlacement","useHeight","fragments","frag","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","priority","primary","escapeWithReference","secondary","shift","shiftvariation","shiftOffsets","bound","inner","subtractLength","getOffsetDistanceInPx","distance","createPopperInstance","popperOptions","config","_extends$1","Popper","mountPopper","followCursor","popperInstance","makeSticky","stickyDuration","removeTransitionDuration","updatePosition","getIndividualSettings","instanceSettings","DefaultsKeys","acc","val","toLowerCase","parse","createPopperElement","animateFill","inertia","animation","arrowSize","size","theme","zIndex","t","_arrow","templateId","createTrigger","handlers","touchHold","listeners","handleTrigger","handler","handleMouseleave","handleBlur","cursorIsOutsideInteractiveBorder","clientX","clientY","interactiveBorder","corePosition","borderWithDistance","exceeds","getEventListenerHandlers","delay","showDelay","touchWait","hideDelay","clearTimeouts","_show","_delay","isArray","show","callbacks","wait","click","isClick","isNotPersistent","handleMousemove","triggerHide","closestTooltippedEl","isOverPopper","isOverEl","isClickTriggered","relatedTarget","createTooltips","idCounter","tippy$2","Tippy","SUPPORTED","userAgent","MSStream","CONTENT","CIRCLE","ARROW","flipDuration","sticky","nativeHints","isBrowser","longerTimeoutBrowsers","supportsNativeMutationObserver","hint","debounce","appVersion","classCallCheck","Constructor","TypeError","createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","assign","placements","onLoad","Defaults$1","jquery","Utils","PopperUtils","classCallCheck$1","createClass$1","destroyed","shown","hidden","error","_this2","customDuration","_makeSync","_this3","_onShownFired","focus","_this4","_ref$settings2","listener","_this5","disableDynamicInputDetection","enableDynamicInputDetection","g","Function","eval"],"mappings":"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","file":"main.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/js\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(2));\r\n__export(__webpack_require__(3));\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(0);\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n    util_1.animateHeader();\r\n    util_1.addTooltipsToHomeIcons();\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tippy = __webpack_require__(9);\r\n__webpack_require__(6);\r\nexports.addTooltipsToHomeIcons = function () {\r\n    tippy('.home__icon', {\r\n        interactive: true,\r\n        performance: true,\r\n        position: 'bottom'\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.animateHeader = function () {\r\n    var heading = document.getElementById('name');\r\n    if (!heading) {\r\n        return;\r\n    }\r\n    var letters = heading.innerHTML.split('');\r\n    // Wrap letters in spans, allowing them to be styled individually\r\n    var wrappedHeading = letters.map(function (letter) {\r\n        return \"<span class=\\\"fancy letter\\\">\" + letter + \"</span>\";\r\n    });\r\n    heading.innerHTML = wrappedHeading.join('');\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \".tippy-touch{cursor:pointer!important}.tippy-notransition{-webkit-transition:none!important;transition:none!important}.tippy-popper{max-width:400px;-webkit-perspective:800px;perspective:800px;z-index:9999;outline:0}.tippy-popper.html-template{max-width:96%;max-width:calc(100% - 20px)}.tippy-popper[x-placement^=top] [x-arrow]{position:absolute;width:0;height:0;border-top:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;bottom:-7px}.tippy-popper[x-placement^=top] [x-arrow].arrow-small{border-top:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;bottom:-5px}.tippy-popper[x-placement^=top] [x-arrow].arrow-big{border-top:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;bottom:-10px}.tippy-popper[x-placement^=top] [x-circle]{-webkit-transform-origin:0 100%;transform-origin:0 100%}.tippy-popper[x-placement^=top] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=top] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-100%);transform:scale(.45) translate(-50%,-100%);opacity:0}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow]{border-top:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-top:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-top:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow]{border-top:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-top:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-top:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(-10px) rotateX(0);transform:translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(90deg);transform:translateY(0) rotateX(90deg)}.tippy-popper[x-placement^=top] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=bottom] [x-arrow]{position:absolute;width:0;height:0;border-bottom:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;top:-7px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-small{border-bottom:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;top:-5px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-big{border-bottom:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;top:-10px}.tippy-popper[x-placement^=bottom] [x-circle]{-webkit-transform-origin:0 -100%;transform-origin:0 -100%}.tippy-popper[x-placement^=bottom] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=bottom] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,8%);transform:scale(.45) translate(-50%,8%);opacity:0}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow]{border-bottom:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-bottom:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-bottom:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow]{border-bottom:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-bottom:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-bottom:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(10px) rotateX(0);transform:translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(-90deg);transform:translateY(0) rotateX(-90deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=left] [x-arrow]{position:absolute;width:0;height:0;border-left:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;right:-7px}.tippy-popper[x-placement^=left] [x-arrow].arrow-small{border-left:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;right:-5px}.tippy-popper[x-placement^=left] [x-arrow].arrow-big{border-left:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;right:-10px}.tippy-popper[x-placement^=left] [x-circle]{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=left] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-50%);transform:scale(.45) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow]{border-left:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-left:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-left:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow]{border-left:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-left:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-left:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(-10px) rotateY(0);transform:translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(-90deg);transform:translateX(0) rotateY(-90deg)}.tippy-popper[x-placement^=left] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper[x-placement^=right] [x-arrow]{position:absolute;width:0;height:0;border-right:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;left:-7px}.tippy-popper[x-placement^=right] [x-arrow].arrow-small{border-right:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;left:-5px}.tippy-popper[x-placement^=right] [x-arrow].arrow-big{border-right:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;left:-10px}.tippy-popper[x-placement^=right] [x-circle]{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=right] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-50%);transform:scale(.45) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow]{border-right:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-right:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-right:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow]{border-right:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-right:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-right:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(10px) rotateY(0);transform:translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(90deg);transform:translateX(0) rotateY(90deg)}.tippy-popper[x-placement^=right] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper .tippy-tooltip.transparent-theme{background-color:rgba(0,0,0,.7)}.tippy-popper .tippy-tooltip.transparent-theme[data-animatefill]{background-color:transparent}.tippy-popper .tippy-tooltip.light-theme{color:#26323d;box-shadow:0 4px 20px 4px rgba(0,20,60,.1),0 4px 80px -8px rgba(0,20,60,.2);background-color:#fff}.tippy-popper .tippy-tooltip.light-theme[data-animatefill]{background-color:transparent}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:.95rem;padding:.4rem .8rem;text-align:center;will-change:transform;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#333;pointer-events:none}.tippy-tooltip--small{padding:.25rem .5rem;font-size:.8rem}.tippy-tooltip--big{padding:.6rem 1.2rem;font-size:1.2rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive]{pointer-events:auto}.tippy-tooltip[data-inertia]{-webkit-transition-timing-function:cubic-bezier(.53,1,.36,.85);transition-timing-function:cubic-bezier(.53,2,.36,.85)}.tippy-tooltip [x-circle]{position:absolute;will-change:transform;background-color:#333;border-radius:50%;width:120%;width:calc(100% + 2rem);-webkit-transition:all ease-out;transition:all ease-out;left:50%;top:50%;z-index:-1;overflow:hidden}.tippy-tooltip [x-circle]:before{content:\\\"\\\";padding-top:75%;float:left}@media (max-width:450px){.tippy-popper{max-width:96%;max-width:calc(100% - 20px)}}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../css-loader/index.js!./tippy.css\", function() {\n\t\t\tvar newContent = require(\"!!../../css-loader/index.js!./tippy.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(8);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.tippy = factory());\n}(this, (function () { 'use strict';\n\nvar Browser = {};\n\nif (typeof window !== 'undefined') {\n    Browser.SUPPORTED = !!window.requestAnimationFrame;\n    Browser.SUPPORTS_TOUCH = 'ontouchstart' in window;\n    Browser.touch = false;\n    // Chrome device/touch emulator can make this dynamic\n    Browser.iOS = function () {\n        return (/iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream\n        );\n    };\n    Browser.dynamicInputDetection = true;\n}\n\nvar Store = [];\n\nvar Selectors = {\n    POPPER: '.tippy-popper',\n    TOOLTIP: '.tippy-tooltip',\n    CONTENT: '.tippy-tooltip-content',\n    CIRCLE: '[x-circle]',\n    ARROW: '[x-arrow]',\n    TOOLTIPPED_EL: '[data-tooltipped]',\n    CONTROLLER: '[data-tippy-controller]'\n};\n\nvar Defaults = {\n    html: false,\n    position: 'top',\n    animation: 'shift',\n    animateFill: true,\n    arrow: false,\n    arrowSize: 'regular',\n    delay: 0,\n    trigger: 'mouseenter focus',\n    duration: 350,\n    interactive: false,\n    interactiveBorder: 2,\n    theme: 'dark',\n    size: 'regular',\n    distance: 10,\n    offset: 0,\n    hideOnClick: true,\n    multiple: false,\n    followCursor: false,\n    inertia: false,\n    flipDuration: 300,\n    sticky: false,\n    stickyDuration: 200,\n    appendTo: null,\n    zIndex: 9999,\n    touchHold: false,\n    performance: false,\n    popperOptions: {}\n};\n\nvar DefaultsKeys = Browser.SUPPORTED && Object.keys(Defaults);\n\n/**\n* Hides all poppers\n* @param {Object} currentRef\n*/\nfunction hideAllPoppers(currentRef) {\n\n    Store.forEach(function (ref) {\n        var popper = ref.popper,\n            tippyInstance = ref.tippyInstance,\n            _ref$settings = ref.settings,\n            appendTo = _ref$settings.appendTo,\n            hideOnClick = _ref$settings.hideOnClick,\n            trigger = _ref$settings.trigger;\n\n        // Don't hide already hidden ones\n\n        if (!appendTo.contains(popper)) return;\n\n        // hideOnClick can have the truthy value of 'persistent', so strict check is needed\n        var isHideOnClick = hideOnClick === true || trigger.indexOf('focus') !== -1;\n        var isNotCurrentRef = !currentRef || popper !== currentRef.popper;\n\n        if (isHideOnClick && isNotCurrentRef) {\n            tippyInstance.hide(popper);\n        }\n    });\n}\n\n/**\n* Ponyfill to get the closest parent element\n* @param {Element} element - child of parent to be returned\n* @param {String} parentSelector - selector to match the parent if found\n* @return {Element}\n*/\nfunction closest(element, parentSelector) {\n    var matches = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || function (s) {\n        var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n            i = matches.length;\n        while (--i >= 0 && matches.item(i) !== this) {}\n        return i > -1;\n    };\n\n    var _closest = Element.prototype.closest || function (selector) {\n        var el = this;\n        while (el) {\n            if (matches.call(el, selector)) {\n                return el;\n            }\n            el = el.parentElement;\n        }\n    };\n\n    return _closest.call(element, parentSelector);\n}\n\n/**\n* Ponyfill for Array.prototype.find\n* @param {Array} arr\n* @param {Function} checkFn\n* @return item in the array\n*/\nfunction find(arr, checkFn) {\n  if (Array.prototype.find) {\n    return arr.find(checkFn);\n  }\n\n  // use `filter` as fallback\n  return arr.filter(checkFn)[0];\n}\n\n/**\n* To run a single time, once DOM is presumed to be ready\n* @return {Boolean} whether the function has run or not\n*/\nfunction init() {\n\n    if (init.done) return false;\n    init.done = true;\n\n    // If the script is in <head>, document.body is null, so it's set in the\n    // init function\n    Defaults.appendTo = document.body;\n\n    var touchHandler = function touchHandler() {\n        Browser.touch = true;\n\n        if (Browser.iOS()) {\n            document.body.classList.add('tippy-touch');\n        }\n\n        if (Browser.dynamicInputDetection) {\n            document.addEventListener('mousemove', mousemoveHandler);\n        }\n    };\n\n    var mousemoveHandler = function () {\n        var time = void 0;\n\n        return function () {\n            var now = performance.now();\n\n            if (now - time < 10) {\n                Browser.touch = false;\n                document.removeEventListener('mousemove', mousemoveHandler);\n                if (!Browser.iOS() && document.body.classList.contains('tippy-touch')) {\n                    document.body.classList.remove('tippy-touch');\n                }\n            }\n\n            time = now;\n        };\n    }();\n\n    var clickHandler = function clickHandler(event) {\n\n        // Simulated events dispatched on the document\n        if (!(event.target instanceof Element)) {\n            return hideAllPoppers();\n        }\n\n        var el = closest(event.target, Selectors.TOOLTIPPED_EL);\n        var popper = closest(event.target, Selectors.POPPER);\n\n        if (popper) {\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var interactive = ref.settings.interactive;\n\n            if (interactive) return;\n        }\n\n        if (el) {\n            var _ref = find(Store, function (ref) {\n                return ref.el === el;\n            });\n            var _ref$settings = _ref.settings,\n                hideOnClick = _ref$settings.hideOnClick,\n                multiple = _ref$settings.multiple,\n                trigger = _ref$settings.trigger;\n\n            // Hide all poppers except the one belonging to the element that was clicked IF\n            // `multiple` is false AND they are a touch user, OR\n            // `multiple` is false AND it's triggered by a click\n\n            if (!multiple && Browser.touch || !multiple && trigger.indexOf('click') !== -1) {\n                return hideAllPoppers(_ref);\n            }\n\n            // If hideOnClick is not strictly true or triggered by a click don't hide poppers\n            if (hideOnClick !== true || trigger.indexOf('click') !== -1) return;\n        }\n\n        // Don't trigger a hide for tippy controllers, and don't needlessly run loop\n        if (closest(event.target, Selectors.CONTROLLER) || !document.querySelector(Selectors.POPPER)) return;\n\n        hideAllPoppers();\n    };\n\n    // Hook events\n    document.addEventListener('click', clickHandler);\n    document.addEventListener('touchstart', touchHandler);\n\n    if (!Browser.SUPPORTS_TOUCH && navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {\n        document.addEventListener('pointerdown', touchHandler);\n    }\n\n    return true;\n}\n\n/**\n* Pushes execution of a function to end of execution queue, doing so\n* on next repaint\n* @return {Function}\n*/\nfunction queueExecution(fn) {\n    window.requestAnimationFrame(function () {\n        setTimeout(fn, 0);\n    });\n}\n\n/**\n* Returns the supported prefixed property - only `webkit` is needed, `moz`, `ms` and `o` are obsolete\n* @param {String} property\n* @return {String} - browser supported prefixed property\n*/\nfunction prefix(property) {\n    var prefixes = [false, 'webkit'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length; i++) {\n        var _prefix = prefixes[i];\n        var prefixedProp = _prefix ? '' + _prefix + upperProp : property;\n        if (typeof window.document.body.style[prefixedProp] !== 'undefined') {\n            return prefixedProp;\n        }\n    }\n\n    return null;\n}\n\n/**\n* Removes the title from the tooltipped element\n* @param {Element} el\n*/\nfunction removeTitle(el) {\n    var title = el.getAttribute('title');\n    el.setAttribute('data-original-title', title || 'html');\n    el.removeAttribute('title');\n}\n\n/**\n* Determines if an element is visible in the viewport\n* @param {Element} el\n* @return {Boolean}\n*/\nfunction elementIsInViewport(el) {\n    var rect = el.getBoundingClientRect();\n\n    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);\n}\n\n/**\n* Triggers a document repaint or reflow for CSS transition\n* @param {Element} tooltip\n* @param {Element} circle\n*/\nfunction triggerReflow(tooltip, circle) {\n    // Safari needs the specific 'transform' property to be accessed\n    circle ? window.getComputedStyle(circle)[prefix('transform')] : window.getComputedStyle(tooltip).opacity;\n}\n\n/**\n* Modifies elements' class lists\n* @param {Array} els - HTML elements\n* @param {Function} callback\n*/\nfunction modifyClassList(els, callback) {\n    els.forEach(function (el) {\n        if (!el) return;\n        callback(el.classList);\n    });\n}\n\n/**\n* Applies the transition duration to each element\n* @param {Array} els - HTML elements\n* @param {Number} duration\n*/\nfunction applyTransitionDuration(els, duration) {\n    var _duration = void 0;\n    els.forEach(function (el) {\n        if (!el) return;\n\n        _duration = duration;\n\n        if (el.hasAttribute('x-circle')) {\n            _duration = Math.round(duration / 1.1);\n        }\n\n        el.style[prefix('transitionDuration')] = _duration + 'ms';\n    });\n}\n\n/**\n* Determines if a popper is currently visible\n* @param {Element} popper\n* @return {Boolean}\n*/\nfunction isVisible(popper) {\n    return popper.style.visibility === 'visible';\n}\n\nfunction noop() {}\n\n/**\n* Returns the non-shifted placement (e.g., 'bottom-start' => 'bottom')\n* @param {String} placement\n* @return {String}\n*/\nfunction getCorePlacement(placement) {\n    return placement.replace(/-.+/, '');\n}\n\n/**\n* Mousemove event listener callback method for follow cursor setting\n* @param {MouseEvent} e\n*/\nfunction followCursorHandler(e) {\n    var _this = this;\n\n    var ref = find(Store, function (ref) {\n        return ref.el === _this;\n    });\n    var popper = ref.popper;\n\n\n    var position = getCorePlacement(popper.getAttribute('x-placement'));\n    var halfPopperWidth = Math.round(popper.offsetWidth / 2);\n    var halfPopperHeight = Math.round(popper.offsetHeight / 2);\n    var viewportPadding = 5;\n    var pageWidth = document.documentElement.offsetWidth || document.body.offsetWidth;\n\n    var pageX = e.pageX,\n        pageY = e.pageY;\n\n\n    var x = void 0,\n        y = void 0;\n\n    switch (position) {\n        case 'top':\n            x = pageX - halfPopperWidth;\n            y = pageY - 2.5 * halfPopperHeight;\n            break;\n        case 'left':\n            x = pageX - 2 * halfPopperWidth - 15;\n            y = pageY - halfPopperHeight;\n            break;\n        case 'right':\n            x = pageX + halfPopperHeight;\n            y = pageY - halfPopperHeight;\n            break;\n        case 'bottom':\n            x = pageX - halfPopperWidth;\n            y = pageY + halfPopperHeight / 1.5;\n            break;\n    }\n\n    var isRightOverflowing = pageX + viewportPadding + halfPopperWidth > pageWidth;\n    var isLeftOverflowing = pageX - viewportPadding - halfPopperWidth < 0;\n\n    // Prevent left/right overflow\n    if (position === 'top' || position === 'bottom') {\n        if (isRightOverflowing) {\n            x = pageWidth - viewportPadding - 2 * halfPopperWidth;\n        }\n\n        if (isLeftOverflowing) {\n            x = viewportPadding;\n        }\n    }\n\n    popper.style[prefix('transform')] = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n}\n\n/**\n* Returns an array of elements based on the selector input\n* @param {String|Element} selector\n* @return {Array} of HTML Elements\n*/\nfunction getArrayOfElementsFromSelector(selector) {\n    if (selector instanceof Element) {\n        return [selector];\n    }\n\n    return [].slice.call(document.querySelectorAll(selector));\n}\n\n/**\n* Prepares the callback functions for `show` and `hide` methods\n* @param {Object} ref -  the element/popper reference\n* @param {Number} duration\n* @param {Function} callback - callback function to fire once transitions complete\n*/\nfunction onTransitionEnd(ref, duration, callback) {\n\n    // Make callback synchronous if duration is 0\n    if (!duration) {\n        return callback();\n    }\n\n    var tooltip = ref.popper.querySelector(Selectors.TOOLTIP);\n    var transitionendFired = false;\n\n    var listenerCallback = function listenerCallback(e) {\n        if (e.target !== tooltip) return;\n\n        transitionendFired = true;\n\n        tooltip.removeEventListener('webkitTransitionEnd', listenerCallback);\n        tooltip.removeEventListener('transitionend', listenerCallback);\n\n        callback();\n    };\n\n    // Wait for transitions to complete\n    tooltip.addEventListener('webkitTransitionEnd', listenerCallback);\n    tooltip.addEventListener('transitionend', listenerCallback);\n\n    // transitionend listener sometimes may not fire\n    clearTimeout(ref._transitionendTimeout);\n    ref._transitionendTimeout = setTimeout(function () {\n        !transitionendFired && callback();\n    }, duration);\n}\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]'];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @method\n * @memberof Popper.Utils\n * @argument {Function | undefined} fn the function to check\n * @returns {Boolean}\n */\nvar isNative = function isNative(fn) {\n  return nativeHints.some(function (hint) {\n    return (fn || '').toString().indexOf(hint) > -1;\n  });\n};\n\nvar isBrowser = typeof window !== 'undefined';\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var scheduled = false;\n  var i = 0;\n  var elem = document.createElement('span');\n\n  // MutationObserver provides a mechanism for scheduling microtasks, which\n  // are scheduled *before* the next task. This gives us a way to debounce\n  // a function but ensure it's called *before* the next paint.\n  var observer = new MutationObserver(function () {\n    fn();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { attributes: true });\n\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      elem.setAttribute('x-index', i);\n      i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n    }\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nvar supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n    return window.document.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || element.firstElementChild.offsetParent === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  // NOTE: 1 DOM access here\n  var offsetParent = element && element.offsetParent;\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return window.document.documentElement;\n  }\n\n  return offsetParent;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return window.document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = window.document.documentElement;\n    var scrollingElement = window.document.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];\n}\n\n/**\n * Tells if you are running Internet Explorer 10\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean} isIE10\n */\nvar isIE10 = undefined;\n\nvar isIE10$1 = function isIE10$1() {\n  if (isIE10 === undefined) {\n    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n  }\n  return isIE10;\n};\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], html['client' + axis], html['offset' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = window.document.body;\n  var html = window.document.documentElement;\n  var computedStyle = isIE10$1() && window.getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  if (isIE10$1()) {\n    try {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } catch (err) {}\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var isIE10 = isIE10$1();\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top,\n    left: childrenRect.left - parentRect.left,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (isHTML || parent.nodeName === 'BODY') {\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = isIE10 && isHTML ? 0 : +styles.borderTopWidth.split('px')[0];\n    var borderLeftWidth = isIE10 && isHTML ? 0 : +styles.borderLeftWidth.split('px')[0];\n    var marginTop = isIE10 && isHTML ? 0 : +styles.marginTop.split('px')[0];\n    var marginLeft = isIE10 && isHTML ? 0 : +styles.marginLeft.split('px')[0];\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var html = window.document.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = getScroll(html);\n  var scrollLeft = getScroll(html, 'left');\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  // NOTE: 1 DOM access here\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(popper));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = window.document.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = window.document.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var commonOffsetParent = findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find$1(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find$1(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier.function) {\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier.function || modifier.fn;\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n  data.offsets.popper.position = 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length - 1; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof window.document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.left = '';\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? window : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  window.addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  window.removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    window.cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if the arrow style has been computed, apply the arrow style\n  if (data.offsets.arrow) {\n    setStyles(data.arrowElement, data.offsets.arrow);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // round sides to avoid blurry text\n  var offsets = {\n    left: Math.round(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.round(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update attributes and styles of `data`\n  data.attributes = attributes;\n  data.styles = _extends({}, styles, data.styles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find$1(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var side = isVertical ? 'top' : 'left';\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  var sideValue = center - getClientRect(data.offsets.popper)[side];\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = {};\n  data.offsets.arrow[side] = Math.round(sideValue);\n  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find$1(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, []\n    // Here we convert the string values into number values (in px)\n    ).map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find$1(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults$1 = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference.jquery ? reference[0] : reference;\n    this.popper = popper.jquery ? popper[0] : popper;\n\n    // make sure to apply the popper position before any computation\n    setStyles(this.popper, { position: 'absolute' });\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    }\n    // sort the modifiers by order\n    ).sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults$1;\n\n/**\n* Returns the distance taking into account the default distance due to\n* the transform: translate setting in CSS\n* @param {Number} distance\n* @return {String}\n*/\nfunction getOffsetDistanceInPx(distance) {\n    return -(distance - Defaults.distance) + 'px';\n}\n\nvar classCallCheck$1 = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass$1 = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends$1 = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n* Creates a new popper instance\n* @param {Object} ref\n* @return {Object} - the popper instance\n*/\nfunction createPopperInstance(ref) {\n    var el = ref.el,\n        popper = ref.popper,\n        _ref$settings = ref.settings,\n        position = _ref$settings.position,\n        popperOptions = _ref$settings.popperOptions,\n        offset = _ref$settings.offset,\n        distance = _ref$settings.distance;\n\n\n    var tooltip = popper.querySelector(Selectors.TOOLTIP);\n\n    var config = _extends$1({\n        placement: position\n    }, popperOptions || {}, {\n        modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {\n            flip: _extends$1({\n                padding: distance + 5 /* 5px from viewport boundary */\n            }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.flip : {}),\n            offset: _extends$1({\n                offset: offset\n            }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.offset : {})\n        }),\n        onUpdate: function onUpdate() {\n            tooltip.style.top = '';\n            tooltip.style.bottom = '';\n            tooltip.style.left = '';\n            tooltip.style.right = '';\n            tooltip.style[getCorePlacement(popper.getAttribute('x-placement'))] = getOffsetDistanceInPx(distance);\n        }\n    });\n\n    return new Popper(el, popper, config);\n}\n\n/**\n* Appends the popper and creates a popper instance if one does not exist\n* Also updates its position if need be and enables event listeners\n* @param {Object} ref -  the element/popper reference\n*/\nfunction mountPopper(ref) {\n    var el = ref.el,\n        popper = ref.popper,\n        _ref$settings = ref.settings,\n        appendTo = _ref$settings.appendTo,\n        followCursor = _ref$settings.followCursor;\n\n    // Already on the DOM\n\n    if (appendTo.contains(popper)) return;\n\n    appendTo.appendChild(popper);\n\n    if (!ref.popperInstance) {\n        // Create instance if it hasn't been created yet\n        ref.popperInstance = createPopperInstance(ref);\n    } else {\n        ref.popperInstance.update();\n\n        if (!followCursor || Browser.touch) {\n            ref.popperInstance.enableEventListeners();\n        }\n    }\n\n    // Since touch is determined dynamically, followCursor setting\n    // is set on mount\n    if (followCursor && !Browser.touch) {\n        el.addEventListener('mousemove', followCursorHandler);\n        ref.popperInstance.disableEventListeners();\n    }\n}\n\n/**\n* Updates a popper's position on each animation frame to make it stick to a moving element\n* @param {Object} ref\n*/\nfunction makeSticky(ref) {\n    var popper = ref.popper,\n        popperInstance = ref.popperInstance,\n        stickyDuration = ref.settings.stickyDuration;\n\n\n    var applyTransitionDuration = function applyTransitionDuration() {\n        return popper.style[prefix('transitionDuration')] = stickyDuration + 'ms';\n    };\n\n    var removeTransitionDuration = function removeTransitionDuration() {\n        return popper.style[prefix('transitionDuration')] = '';\n    };\n\n    var updatePosition = function updatePosition() {\n        popperInstance && popperInstance.scheduleUpdate();\n\n        applyTransitionDuration();\n\n        isVisible(popper) ? window.requestAnimationFrame(updatePosition) : removeTransitionDuration();\n    };\n\n    // Wait until Popper's position has been updated initially\n    queueExecution(updatePosition);\n}\n\n/**\n* Returns an object of settings to override global settings\n* @param {Element} el - the tooltipped element\n* @param {Object} instanceSettings\n* @return {Object} - individual settings\n*/\nfunction getIndividualSettings(el, instanceSettings) {\n\n    var settings = DefaultsKeys.reduce(function (acc, key) {\n        var val = el.getAttribute('data-' + key.toLowerCase()) || instanceSettings[key];\n\n        // Convert strings to booleans\n        if (val === 'false') val = false;\n        if (val === 'true') val = true;\n\n        // Convert number strings to true numbers\n        if (isFinite(val) && !isNaN(parseFloat(val))) {\n            val = parseFloat(val);\n        }\n\n        // Convert array strings to actual arrays\n        if (typeof val === 'string' && val.trim().charAt(0) === '[') {\n            val = JSON.parse(val);\n        }\n\n        acc[key] = val;\n\n        return acc;\n    }, {});\n\n    return _extends$1({}, instanceSettings, settings);\n}\n\n/**\n* Creates a popper element then returns it\n* @param {Number} id - the popper id\n* @param {String} title - the tooltip's `title` attribute\n* @param {Object} settings - individual settings\n* @return {Element} - the popper element\n*/\nfunction createPopperElement(id, title, settings) {\n    var position = settings.position,\n        distance = settings.distance,\n        arrow = settings.arrow,\n        animateFill = settings.animateFill,\n        inertia = settings.inertia,\n        animation = settings.animation,\n        arrowSize = settings.arrowSize,\n        size = settings.size,\n        theme = settings.theme,\n        html = settings.html,\n        zIndex = settings.zIndex,\n        interactive = settings.interactive;\n\n\n    var popper = document.createElement('div');\n    popper.setAttribute('class', 'tippy-popper');\n    popper.setAttribute('role', 'tooltip');\n    popper.setAttribute('aria-hidden', 'true');\n    popper.setAttribute('id', 'tippy-tooltip-' + id);\n    popper.style.zIndex = zIndex;\n\n    var tooltip = document.createElement('div');\n    tooltip.setAttribute('class', 'tippy-tooltip tippy-tooltip--' + size + ' leave');\n    tooltip.setAttribute('data-animation', animation);\n\n    theme.split(' ').forEach(function (t) {\n        tooltip.classList.add(t + '-theme');\n    });\n\n    if (arrow) {\n        // Add an arrow\n        var _arrow = document.createElement('div');\n        _arrow.setAttribute('class', 'arrow-' + arrowSize);\n        _arrow.setAttribute('x-arrow', '');\n        tooltip.appendChild(_arrow);\n    }\n\n    if (animateFill) {\n        // Create animateFill circle element for animation\n        tooltip.setAttribute('data-animatefill', '');\n        var circle = document.createElement('div');\n        circle.setAttribute('class', 'leave');\n        circle.setAttribute('x-circle', '');\n        tooltip.appendChild(circle);\n    }\n\n    if (inertia) {\n        // Change transition timing function cubic bezier\n        tooltip.setAttribute('data-inertia', '');\n    }\n\n    if (interactive) {\n        tooltip.setAttribute('data-interactive', '');\n    }\n\n    // Tooltip content (text or HTML)\n    var content = document.createElement('div');\n    content.setAttribute('class', 'tippy-tooltip-content');\n\n    if (html) {\n\n        var templateId = void 0;\n\n        if (html instanceof Element) {\n            content.appendChild(html);\n            templateId = html.id || 'tippy-html-template';\n        } else {\n            content.innerHTML = document.getElementById(html.replace('#', '')).innerHTML;\n            templateId = html;\n        }\n\n        popper.classList.add('html-template');\n        popper.setAttribute('tabindex', '0');\n        tooltip.setAttribute('data-template-id', templateId);\n    } else {\n        content.innerHTML = title;\n    }\n\n    // Init distance. Further updates are made in the popper instance's `onUpdate()` method\n    tooltip.style[getCorePlacement(position)] = getOffsetDistanceInPx(distance);\n\n    tooltip.appendChild(content);\n    popper.appendChild(tooltip);\n\n    return popper;\n}\n\n/**\n* Creates a trigger\n* @param {Object} event - the custom event specified in the `trigger` setting\n* @param {Element} el - tooltipped element\n* @param {Object} handlers - the handlers for each listener\n* @return {Array} - array of listener objects\n*/\nfunction createTrigger(event, el, handlers, touchHold) {\n    var listeners = [];\n\n    if (event === 'manual') return listeners;\n\n    // Enter\n    el.addEventListener(event, handlers.handleTrigger);\n    listeners.push({\n        event: event,\n        handler: handlers.handleTrigger\n    });\n\n    // Leave\n    if (event === 'mouseenter') {\n\n        if (Browser.SUPPORTS_TOUCH && touchHold) {\n            el.addEventListener('touchstart', handlers.handleTrigger);\n            listeners.push({\n                event: 'touchstart',\n                handler: handlers.handleTrigger\n            });\n            el.addEventListener('touchend', handlers.handleMouseleave);\n            listeners.push({\n                event: 'touchend',\n                handler: handlers.handleMouseleave\n            });\n        }\n\n        el.addEventListener('mouseleave', handlers.handleMouseleave);\n        listeners.push({\n            event: 'mouseleave',\n            handler: handlers.handleMouseleave\n        });\n    }\n\n    if (event === 'focus') {\n        el.addEventListener('blur', handlers.handleBlur);\n        listeners.push({\n            event: 'blur',\n            handler: handlers.handleBlur\n        });\n    }\n\n    return listeners;\n}\n\n/**\n* Determines if the mouse's cursor is outside the interactive border\n* @param {MouseEvent} event\n* @param {Element} popper\n* @param {Object} settings\n* @return {Boolean}\n*/\nfunction cursorIsOutsideInteractiveBorder(event, popper, settings) {\n    if (!popper.getAttribute('x-placement')) return true;\n\n    var x = event.clientX,\n        y = event.clientY;\n    var interactiveBorder = settings.interactiveBorder,\n        distance = settings.distance;\n\n\n    var rect = popper.getBoundingClientRect();\n    var corePosition = getCorePlacement(popper.getAttribute('x-placement'));\n    var borderWithDistance = interactiveBorder + distance;\n\n    var exceeds = {\n        top: rect.top - y > interactiveBorder,\n        bottom: y - rect.bottom > interactiveBorder,\n        left: rect.left - x > interactiveBorder,\n        right: x - rect.right > interactiveBorder\n    };\n\n    switch (corePosition) {\n        case 'top':\n            exceeds.top = rect.top - y > borderWithDistance;\n            break;\n        case 'bottom':\n            exceeds.bottom = y - rect.bottom > borderWithDistance;\n            break;\n        case 'left':\n            exceeds.left = rect.left - x > borderWithDistance;\n            break;\n        case 'right':\n            exceeds.right = x - rect.right > borderWithDistance;\n            break;\n    }\n\n    return exceeds.top || exceeds.bottom || exceeds.left || exceeds.right;\n}\n\n/**\n* Returns relevant listener callbacks for each ref\n* @param {Element} el\n* @param {Element} popper\n* @param {Object} settings\n* @return {Object} - relevant listener callback methods\n*/\nfunction getEventListenerHandlers(el, popper, settings) {\n    var _this = this;\n\n    var position = settings.position,\n        delay = settings.delay,\n        duration = settings.duration,\n        interactive = settings.interactive,\n        interactiveBorder = settings.interactiveBorder,\n        distance = settings.distance,\n        hideOnClick = settings.hideOnClick,\n        trigger = settings.trigger,\n        touchHold = settings.touchHold,\n        touchWait = settings.touchWait;\n\n\n    var showDelay = void 0,\n        hideDelay = void 0;\n\n    var clearTimeouts = function clearTimeouts() {\n        clearTimeout(showDelay);\n        clearTimeout(hideDelay);\n    };\n\n    var _show = function _show() {\n        clearTimeouts();\n\n        // Not hidden. For clicking when it also has a `focus` event listener\n        if (isVisible(popper)) return;\n\n        var _delay = Array.isArray(delay) ? delay[0] : delay;\n\n        if (delay) {\n            showDelay = setTimeout(function () {\n                return _this.show(popper);\n            }, _delay);\n        } else {\n            _this.show(popper);\n        }\n    };\n\n    var show = function show(event) {\n        return _this.callbacks.wait ? _this.callbacks.wait.call(popper, _show, event) : _show();\n    };\n\n    var hide = function hide() {\n        clearTimeouts();\n\n        var _delay = Array.isArray(delay) ? delay[1] : delay;\n\n        if (delay) {\n            hideDelay = setTimeout(function () {\n                return _this.hide(popper);\n            }, _delay);\n        } else {\n            _this.hide(popper);\n        }\n    };\n\n    var handleTrigger = function handleTrigger(event) {\n\n        if (event.type === 'mouseenter' && Browser.SUPPORTS_TOUCH && Browser.touch) {\n            if (touchHold) return;\n            if (Browser.iOS()) el.click();\n        }\n\n        // Toggle show/hide when clicking click-triggered tooltips\n        var isClick = event.type === 'click';\n        var isNotPersistent = hideOnClick !== 'persistent';\n\n        isClick && isVisible(popper) && isNotPersistent ? hide() : show(event);\n    };\n\n    var handleMouseleave = function handleMouseleave(event) {\n\n        // Don't fire 'mouseleave', use the 'touchend'\n        if (event.type === 'mouseleave' && Browser.SUPPORTS_TOUCH && Browser.touch && touchHold) {\n            return;\n        }\n\n        if (interactive) {\n            // Temporarily handle mousemove to check if the mouse left somewhere\n            // other than its popper\n            var handleMousemove = function handleMousemove(event) {\n\n                var triggerHide = function triggerHide() {\n                    document.body.removeEventListener('mouseleave', hide);\n                    document.removeEventListener('mousemove', handleMousemove);\n                    hide();\n                };\n\n                var closestTooltippedEl = closest(event.target, Selectors.TOOLTIPPED_EL);\n\n                var isOverPopper = closest(event.target, Selectors.POPPER) === popper;\n                var isOverEl = closestTooltippedEl === el;\n                var isClickTriggered = trigger.indexOf('click') !== -1;\n                var isOverOtherTooltippedEl = closestTooltippedEl && closestTooltippedEl !== el;\n\n                if (isOverOtherTooltippedEl) {\n                    return triggerHide();\n                }\n\n                if (isOverPopper || isOverEl || isClickTriggered) return;\n\n                if (cursorIsOutsideInteractiveBorder(event, popper, settings)) {\n                    triggerHide();\n                }\n            };\n\n            document.body.addEventListener('mouseleave', hide);\n            document.addEventListener('mousemove', handleMousemove);\n\n            return;\n        }\n\n        // If it's not interactive, just hide it\n        hide();\n    };\n\n    var handleBlur = function handleBlur(event) {\n        // Ignore blur on touch devices, if there is no `relatedTarget`, hide\n        // If the related target is a popper, ignore\n        if (Browser.touch || !event.relatedTarget) return;\n        if (closest(event.relatedTarget, Selectors.POPPER)) return;\n\n        hide();\n    };\n\n    return {\n        handleTrigger: handleTrigger,\n        handleMouseleave: handleMouseleave,\n        handleBlur: handleBlur\n    };\n}\n\nvar idCounter = 1;\n\n/**\n* Creates tooltips for all el elements that match the instance's selector\n* @param {Array} els - Elements\n*/\nfunction createTooltips(els) {\n    var _this = this;\n\n    els.forEach(function (el) {\n\n        var settings = _this.settings.performance ? _this.settings : getIndividualSettings(el, _this.settings);\n\n        // animateFill is disabled if an arrow is true\n        if (settings.arrow) settings.animateFill = false;\n\n        var html = settings.html,\n            trigger = settings.trigger,\n            touchHold = settings.touchHold;\n\n\n        var title = el.getAttribute('title');\n        if (!title && !html) return;\n\n        var id = idCounter;\n        el.setAttribute('data-tooltipped', '');\n        el.setAttribute('aria-describedby', 'tippy-tooltip-' + id);\n\n        removeTitle(el);\n\n        var popper = createPopperElement(id, title, settings);\n        var handlers = getEventListenerHandlers.call(_this, el, popper, settings);\n        var listeners = [];\n\n        trigger.trim().split(' ').forEach(function (event) {\n            return listeners = listeners.concat(createTrigger(event, el, handlers, touchHold));\n        });\n\n        Store.push({\n            id: id,\n            el: el,\n            popper: popper,\n            settings: settings,\n            listeners: listeners,\n            tippyInstance: _this\n        });\n\n        idCounter++;\n    });\n}\n\n/* Utility functions */\n/* Core library functions */\n/**\n* @param {String|Element} selector\n* @param {Object} settings (optional) - the object of settings to be applied to the instance\n*/\n\nvar Tippy = function () {\n    function Tippy(selector) {\n        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        classCallCheck$1(this, Tippy);\n\n\n        // Use default browser tooltip on unsupported browsers\n        if (!Browser.SUPPORTED) return;\n\n        // DOM is presumably mostly ready (for document.body) by instantiation time\n        init();\n\n        this.state = {\n            destroyed: false\n        };\n\n        this.selector = selector;\n\n        this.settings = _extends$1({}, Defaults, settings);\n\n        this.callbacks = {\n            wait: settings.wait,\n            show: settings.show || noop,\n            shown: settings.shown || noop,\n            hide: settings.hide || noop,\n            hidden: settings.hidden || noop\n        };\n\n        createTooltips.call(this, getArrayOfElementsFromSelector(selector));\n    }\n\n    /**\n    * Returns the reference element's popper element\n    * @param {Element} el\n    * @return {Element}\n    */\n\n\n    createClass$1(Tippy, [{\n        key: 'getPopperElement',\n        value: function getPopperElement(el) {\n            var _this = this;\n\n            try {\n                return find(Store.filter(function (ref) {\n                    return ref.tippyInstance === _this;\n                }), function (ref) {\n                    return ref.el === el;\n                }).popper;\n            } catch (e) {\n                console.error('[getPopperElement]: Element passed as the argument does not exist in the instance');\n            }\n        }\n\n        /**\n        * Returns a popper's element reference\n        * @param {Element} popper\n        * @return {Element}\n        */\n\n    }, {\n        key: 'getReferenceElement',\n        value: function getReferenceElement(popper) {\n            var _this2 = this;\n\n            try {\n                return find(Store.filter(function (ref) {\n                    return ref.tippyInstance === _this2;\n                }), function (ref) {\n                    return ref.popper === popper;\n                }).el;\n            } catch (e) {\n                console.error('[getReferenceElement]: Popper passed as the argument does not exist in the instance');\n            }\n        }\n\n        /**\n        * Returns the reference data object from either the reference element or popper element\n        * @param {Element} x (reference element or popper)\n        * @return {Object}\n        */\n\n    }, {\n        key: 'getReferenceData',\n        value: function getReferenceData(x) {\n            return find(Store, function (ref) {\n                return ref.el === x || ref.popper === x;\n            });\n        }\n\n        /**\n        * Shows a popper\n        * @param {Element} popper\n        * @param {Number} customDuration (optional)\n        * @param {Boolean} _makeSync internal param for testing, makes it synchronous\n        */\n\n    }, {\n        key: 'show',\n        value: function show(popper, customDuration, _makeSync) {\n            var _this3 = this;\n\n            if (this.state.destroyed) return;\n\n            this.callbacks.show.call(popper);\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var tooltip = popper.querySelector(Selectors.TOOLTIP);\n            var circle = popper.querySelector(Selectors.CIRCLE);\n\n            var el = ref.el,\n                _ref$settings = ref.settings,\n                appendTo = _ref$settings.appendTo,\n                sticky = _ref$settings.sticky,\n                interactive = _ref$settings.interactive,\n                followCursor = _ref$settings.followCursor,\n                flipDuration = _ref$settings.flipDuration,\n                duration = _ref$settings.duration;\n\n\n            var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[0] : duration;\n\n            // Remove transition duration (prevent a transition when popper changes posiiton)\n            applyTransitionDuration([popper, tooltip, circle], 0);\n\n            mountPopper(ref);\n\n            popper.style.visibility = 'visible';\n            popper.setAttribute('aria-hidden', 'false');\n\n            // Wait for popper to update position and alter x-placement\n            queueExecution(function () {\n                if (!isVisible(popper)) return;\n\n                // Sometimes the arrow will not be in the correct position,\n                // force another update\n                if (!followCursor || Browser.touch) {\n                    ref.popperInstance.update();\n                }\n\n                // Re-apply transition durations\n                applyTransitionDuration([tooltip, circle], _duration, true);\n                if (!followCursor || Browser.touch) {\n                    applyTransitionDuration([popper], flipDuration, true);\n                }\n\n                // Interactive tooltips receive a class of 'active'\n                interactive && el.classList.add('active');\n\n                // Update popper's position on every animation frame\n                sticky && makeSticky(ref);\n\n                // Repaint/reflow is required for CSS transition when appending\n                triggerReflow(tooltip, circle);\n\n                modifyClassList([tooltip, circle], function (list) {\n                    list.contains('tippy-notransition') && list.remove('tippy-notransition');\n                    list.remove('leave');\n                    list.add('enter');\n                });\n\n                // Wait for transitions to complete\n                onTransitionEnd(ref, _duration, function () {\n                    if (!isVisible(popper) || ref._onShownFired) return;\n\n                    // Focus interactive tooltips only\n                    interactive && popper.focus();\n\n                    // Remove transitions from tooltip\n                    tooltip.classList.add('tippy-notransition');\n\n                    // Prevents shown() from firing more than once from early transition cancellations\n                    ref._onShownFired = true;\n\n                    _this3.callbacks.shown.call(popper);\n                });\n            });\n        }\n\n        /**\n        * Hides a popper\n        * @param {Element} popper\n        * @param {Number} customDuration (optional)\n        */\n\n    }, {\n        key: 'hide',\n        value: function hide(popper, customDuration) {\n            var _this4 = this;\n\n            if (this.state.destroyed) return;\n\n            this.callbacks.hide.call(popper);\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var tooltip = popper.querySelector(Selectors.TOOLTIP);\n            var circle = popper.querySelector(Selectors.CIRCLE);\n            var content = popper.querySelector(Selectors.CONTENT);\n\n            var el = ref.el,\n                _ref$settings2 = ref.settings,\n                appendTo = _ref$settings2.appendTo,\n                sticky = _ref$settings2.sticky,\n                interactive = _ref$settings2.interactive,\n                followCursor = _ref$settings2.followCursor,\n                html = _ref$settings2.html,\n                trigger = _ref$settings2.trigger,\n                duration = _ref$settings2.duration;\n\n\n            var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[1] : duration;\n\n            ref._onShownFired = false;\n            interactive && el.classList.remove('active');\n\n            popper.style.visibility = 'hidden';\n            popper.setAttribute('aria-hidden', 'true');\n\n            applyTransitionDuration([tooltip, circle], _duration);\n\n            modifyClassList([tooltip, circle], function (list) {\n                list.contains('tippy-tooltip') && list.remove('tippy-notransition');\n                list.remove('enter');\n                list.add('leave');\n            });\n\n            // Re-focus click-triggered html elements\n            // and the tooltipped element IS in the viewport (otherwise it causes unsightly scrolling\n            // if the tooltip is closed and the element isn't in the viewport anymore)\n            if (html && trigger.indexOf('click') !== -1 && elementIsInViewport(el)) {\n                el.focus();\n            }\n\n            // Wait for transitions to complete\n            onTransitionEnd(ref, _duration, function () {\n                if (isVisible(popper) || !appendTo.contains(popper)) return;\n\n                el.removeEventListener('mousemove', followCursorHandler);\n                ref.popperInstance.disableEventListeners();\n\n                appendTo.removeChild(popper);\n\n                _this4.callbacks.hidden.call(popper);\n            });\n        }\n\n        /**\n        * Destroys a popper\n        * @param {Element} popper\n        */\n\n    }, {\n        key: 'destroy',\n        value: function destroy(popper) {\n            if (this.state.destroyed) return;\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var el = ref.el,\n                popperInstance = ref.popperInstance,\n                listeners = ref.listeners;\n\n            // Ensure the popper is hidden\n\n            if (isVisible(popper)) {\n                this.hide(popper, 0);\n            }\n\n            // Remove Tippy-only event listeners from tooltipped element\n            listeners.forEach(function (listener) {\n                return el.removeEventListener(listener.event, listener.handler);\n            });\n\n            // ReStore original title\n            el.setAttribute('title', el.getAttribute('data-original-title'));\n\n            el.removeAttribute('data-original-title');\n            el.removeAttribute('data-tooltipped');\n            el.removeAttribute('aria-describedby');\n\n            popperInstance && popperInstance.destroy();\n\n            // Remove from storage\n            Store.splice(Store.map(function (ref) {\n                return ref.popper;\n            }).indexOf(popper), 1);\n        }\n\n        /**\n        * Updates a popper with new content\n        * @param {Element} popper\n        */\n\n    }, {\n        key: 'update',\n        value: function update(popper) {\n            if (this.state.destroyed) return;\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var content = popper.querySelector(Selectors.CONTENT);\n            var el = ref.el,\n                html = ref.settings.html;\n\n\n            if (html) {\n                content.innerHTML = html instanceof Element ? html.innerHTML : document.getElementById(html.replace('#', '')).innerHTML;\n            } else {\n                content.innerHTML = el.getAttribute('title') || el.getAttribute('data-original-title');\n                removeTitle(el);\n            }\n        }\n    }, {\n        key: 'destroyAll',\n        value: function destroyAll() {\n            var _this5 = this;\n\n            if (this.state.destroyed) return;\n\n            Store.filter(function (ref) {\n                return ref.tippyInstance === _this5;\n            }).forEach(function (ref) {\n                _this5.destroy(ref.popper);\n            });\n\n            this.state.destroyed = true;\n        }\n    }]);\n    return Tippy;\n}();\n\nfunction tippy$2(selector, settings) {\n    return new Tippy(selector, settings);\n}\n\ntippy$2.Browser = Browser;\ntippy$2.Defaults = Defaults;\ntippy$2.disableDynamicInputDetection = function () {\n    return Browser.dynamicInputDetection = false;\n};\ntippy$2.enableDynamicInputDetection = function () {\n    return Browser.dynamicInputDetection = true;\n};\n\nreturn tippy$2;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// main.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 612efa4e39356f527593","export * from './add-tooltips-to-home-icons';\nexport * from './animate-header';\n\n\n\n// WEBPACK FOOTER //\n// ./_src/util/index.ts","import { addTooltipsToHomeIcons, animateHeader } from './util';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    animateHeader();\n    addTooltipsToHomeIcons();\n});\n\n\n\n// WEBPACK FOOTER //\n// ./_src/main.ts","const tippy = require('tippy.js/dist/tippy');\n\nrequire('tippy.js/dist/tippy.css')\n\nexport const addTooltipsToHomeIcons = () => {\n    tippy('.home__icon', {\n        interactive: true,\n        performance: true,\n        position: 'bottom'\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./_src/util/add-tooltips-to-home-icons.ts","export const animateHeader = () => {\n    const heading = document.getElementById('name');\n\n    if (!heading) {\n        return;\n    }\n\n    const letters = heading.innerHTML.split('');\n\n    // Wrap letters in spans, allowing them to be styled individually\n    const wrappedHeading = letters.map(letter => {\n        return `<span class=\"fancy letter\">${letter}</span>`;\n    });\n\n    heading.innerHTML = wrappedHeading.join('');\n};\n\n\n\n// WEBPACK FOOTER //\n// ./_src/util/animate-header.ts","exports = module.exports = require(\"../../css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".tippy-touch{cursor:pointer!important}.tippy-notransition{-webkit-transition:none!important;transition:none!important}.tippy-popper{max-width:400px;-webkit-perspective:800px;perspective:800px;z-index:9999;outline:0}.tippy-popper.html-template{max-width:96%;max-width:calc(100% - 20px)}.tippy-popper[x-placement^=top] [x-arrow]{position:absolute;width:0;height:0;border-top:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;bottom:-7px}.tippy-popper[x-placement^=top] [x-arrow].arrow-small{border-top:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;bottom:-5px}.tippy-popper[x-placement^=top] [x-arrow].arrow-big{border-top:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;bottom:-10px}.tippy-popper[x-placement^=top] [x-circle]{-webkit-transform-origin:0 100%;transform-origin:0 100%}.tippy-popper[x-placement^=top] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=top] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-100%);transform:scale(.45) translate(-50%,-100%);opacity:0}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow]{border-top:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-top:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-top:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow]{border-top:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-top:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-top:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(-10px) rotateX(0);transform:translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(90deg);transform:translateY(0) rotateX(90deg)}.tippy-popper[x-placement^=top] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=bottom] [x-arrow]{position:absolute;width:0;height:0;border-bottom:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;top:-7px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-small{border-bottom:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;top:-5px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-big{border-bottom:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;top:-10px}.tippy-popper[x-placement^=bottom] [x-circle]{-webkit-transform-origin:0 -100%;transform-origin:0 -100%}.tippy-popper[x-placement^=bottom] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=bottom] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,8%);transform:scale(.45) translate(-50%,8%);opacity:0}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow]{border-bottom:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-bottom:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-bottom:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow]{border-bottom:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-bottom:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-bottom:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(10px) rotateX(0);transform:translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(-90deg);transform:translateY(0) rotateX(-90deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=left] [x-arrow]{position:absolute;width:0;height:0;border-left:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;right:-7px}.tippy-popper[x-placement^=left] [x-arrow].arrow-small{border-left:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;right:-5px}.tippy-popper[x-placement^=left] [x-arrow].arrow-big{border-left:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;right:-10px}.tippy-popper[x-placement^=left] [x-circle]{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=left] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-50%);transform:scale(.45) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow]{border-left:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-left:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-left:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow]{border-left:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-left:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-left:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(-10px) rotateY(0);transform:translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(-90deg);transform:translateX(0) rotateY(-90deg)}.tippy-popper[x-placement^=left] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper[x-placement^=right] [x-arrow]{position:absolute;width:0;height:0;border-right:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;left:-7px}.tippy-popper[x-placement^=right] [x-arrow].arrow-small{border-right:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;left:-5px}.tippy-popper[x-placement^=right] [x-arrow].arrow-big{border-right:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;left:-10px}.tippy-popper[x-placement^=right] [x-circle]{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=right] [x-circle].leave{-webkit-transform:scale(.45) translate(-50%,-50%);transform:scale(.45) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow]{border-right:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-right:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-right:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow]{border-right:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-right:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-right:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(10px) rotateY(0);transform:translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(90deg);transform:translateX(0) rotateY(90deg)}.tippy-popper[x-placement^=right] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper .tippy-tooltip.transparent-theme{background-color:rgba(0,0,0,.7)}.tippy-popper .tippy-tooltip.transparent-theme[data-animatefill]{background-color:transparent}.tippy-popper .tippy-tooltip.light-theme{color:#26323d;box-shadow:0 4px 20px 4px rgba(0,20,60,.1),0 4px 80px -8px rgba(0,20,60,.2);background-color:#fff}.tippy-popper .tippy-tooltip.light-theme[data-animatefill]{background-color:transparent}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:.95rem;padding:.4rem .8rem;text-align:center;will-change:transform;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#333;pointer-events:none}.tippy-tooltip--small{padding:.25rem .5rem;font-size:.8rem}.tippy-tooltip--big{padding:.6rem 1.2rem;font-size:1.2rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive]{pointer-events:auto}.tippy-tooltip[data-inertia]{-webkit-transition-timing-function:cubic-bezier(.53,1,.36,.85);transition-timing-function:cubic-bezier(.53,2,.36,.85)}.tippy-tooltip [x-circle]{position:absolute;will-change:transform;background-color:#333;border-radius:50%;width:120%;width:calc(100% + 2rem);-webkit-transition:all ease-out;transition:all ease-out;left:50%;top:50%;z-index:-1;overflow:hidden}.tippy-tooltip [x-circle]:before{content:\\\"\\\";padding-top:75%;float:left}@media (max-width:450px){.tippy-popper{max-width:96%;max-width:calc(100% - 20px)}}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/tippy.js/dist/tippy.css\n// module id = 4\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 5\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/index.js!./tippy.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../../style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../css-loader/index.js!./tippy.css\", function() {\n\t\t\tvar newContent = require(\"!!../../css-loader/index.js!./tippy.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tippy.js/dist/tippy.css\n// module id = 6\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/lib/addStyles.js\n// module id = 7\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/lib/urls.js\n// module id = 8\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.tippy = factory());\n}(this, (function () { 'use strict';\n\nvar Browser = {};\n\nif (typeof window !== 'undefined') {\n    Browser.SUPPORTED = !!window.requestAnimationFrame;\n    Browser.SUPPORTS_TOUCH = 'ontouchstart' in window;\n    Browser.touch = false;\n    // Chrome device/touch emulator can make this dynamic\n    Browser.iOS = function () {\n        return (/iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream\n        );\n    };\n    Browser.dynamicInputDetection = true;\n}\n\nvar Store = [];\n\nvar Selectors = {\n    POPPER: '.tippy-popper',\n    TOOLTIP: '.tippy-tooltip',\n    CONTENT: '.tippy-tooltip-content',\n    CIRCLE: '[x-circle]',\n    ARROW: '[x-arrow]',\n    TOOLTIPPED_EL: '[data-tooltipped]',\n    CONTROLLER: '[data-tippy-controller]'\n};\n\nvar Defaults = {\n    html: false,\n    position: 'top',\n    animation: 'shift',\n    animateFill: true,\n    arrow: false,\n    arrowSize: 'regular',\n    delay: 0,\n    trigger: 'mouseenter focus',\n    duration: 350,\n    interactive: false,\n    interactiveBorder: 2,\n    theme: 'dark',\n    size: 'regular',\n    distance: 10,\n    offset: 0,\n    hideOnClick: true,\n    multiple: false,\n    followCursor: false,\n    inertia: false,\n    flipDuration: 300,\n    sticky: false,\n    stickyDuration: 200,\n    appendTo: null,\n    zIndex: 9999,\n    touchHold: false,\n    performance: false,\n    popperOptions: {}\n};\n\nvar DefaultsKeys = Browser.SUPPORTED && Object.keys(Defaults);\n\n/**\n* Hides all poppers\n* @param {Object} currentRef\n*/\nfunction hideAllPoppers(currentRef) {\n\n    Store.forEach(function (ref) {\n        var popper = ref.popper,\n            tippyInstance = ref.tippyInstance,\n            _ref$settings = ref.settings,\n            appendTo = _ref$settings.appendTo,\n            hideOnClick = _ref$settings.hideOnClick,\n            trigger = _ref$settings.trigger;\n\n        // Don't hide already hidden ones\n\n        if (!appendTo.contains(popper)) return;\n\n        // hideOnClick can have the truthy value of 'persistent', so strict check is needed\n        var isHideOnClick = hideOnClick === true || trigger.indexOf('focus') !== -1;\n        var isNotCurrentRef = !currentRef || popper !== currentRef.popper;\n\n        if (isHideOnClick && isNotCurrentRef) {\n            tippyInstance.hide(popper);\n        }\n    });\n}\n\n/**\n* Ponyfill to get the closest parent element\n* @param {Element} element - child of parent to be returned\n* @param {String} parentSelector - selector to match the parent if found\n* @return {Element}\n*/\nfunction closest(element, parentSelector) {\n    var matches = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || function (s) {\n        var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n            i = matches.length;\n        while (--i >= 0 && matches.item(i) !== this) {}\n        return i > -1;\n    };\n\n    var _closest = Element.prototype.closest || function (selector) {\n        var el = this;\n        while (el) {\n            if (matches.call(el, selector)) {\n                return el;\n            }\n            el = el.parentElement;\n        }\n    };\n\n    return _closest.call(element, parentSelector);\n}\n\n/**\n* Ponyfill for Array.prototype.find\n* @param {Array} arr\n* @param {Function} checkFn\n* @return item in the array\n*/\nfunction find(arr, checkFn) {\n  if (Array.prototype.find) {\n    return arr.find(checkFn);\n  }\n\n  // use `filter` as fallback\n  return arr.filter(checkFn)[0];\n}\n\n/**\n* To run a single time, once DOM is presumed to be ready\n* @return {Boolean} whether the function has run or not\n*/\nfunction init() {\n\n    if (init.done) return false;\n    init.done = true;\n\n    // If the script is in <head>, document.body is null, so it's set in the\n    // init function\n    Defaults.appendTo = document.body;\n\n    var touchHandler = function touchHandler() {\n        Browser.touch = true;\n\n        if (Browser.iOS()) {\n            document.body.classList.add('tippy-touch');\n        }\n\n        if (Browser.dynamicInputDetection) {\n            document.addEventListener('mousemove', mousemoveHandler);\n        }\n    };\n\n    var mousemoveHandler = function () {\n        var time = void 0;\n\n        return function () {\n            var now = performance.now();\n\n            if (now - time < 10) {\n                Browser.touch = false;\n                document.removeEventListener('mousemove', mousemoveHandler);\n                if (!Browser.iOS() && document.body.classList.contains('tippy-touch')) {\n                    document.body.classList.remove('tippy-touch');\n                }\n            }\n\n            time = now;\n        };\n    }();\n\n    var clickHandler = function clickHandler(event) {\n\n        // Simulated events dispatched on the document\n        if (!(event.target instanceof Element)) {\n            return hideAllPoppers();\n        }\n\n        var el = closest(event.target, Selectors.TOOLTIPPED_EL);\n        var popper = closest(event.target, Selectors.POPPER);\n\n        if (popper) {\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var interactive = ref.settings.interactive;\n\n            if (interactive) return;\n        }\n\n        if (el) {\n            var _ref = find(Store, function (ref) {\n                return ref.el === el;\n            });\n            var _ref$settings = _ref.settings,\n                hideOnClick = _ref$settings.hideOnClick,\n                multiple = _ref$settings.multiple,\n                trigger = _ref$settings.trigger;\n\n            // Hide all poppers except the one belonging to the element that was clicked IF\n            // `multiple` is false AND they are a touch user, OR\n            // `multiple` is false AND it's triggered by a click\n\n            if (!multiple && Browser.touch || !multiple && trigger.indexOf('click') !== -1) {\n                return hideAllPoppers(_ref);\n            }\n\n            // If hideOnClick is not strictly true or triggered by a click don't hide poppers\n            if (hideOnClick !== true || trigger.indexOf('click') !== -1) return;\n        }\n\n        // Don't trigger a hide for tippy controllers, and don't needlessly run loop\n        if (closest(event.target, Selectors.CONTROLLER) || !document.querySelector(Selectors.POPPER)) return;\n\n        hideAllPoppers();\n    };\n\n    // Hook events\n    document.addEventListener('click', clickHandler);\n    document.addEventListener('touchstart', touchHandler);\n\n    if (!Browser.SUPPORTS_TOUCH && navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {\n        document.addEventListener('pointerdown', touchHandler);\n    }\n\n    return true;\n}\n\n/**\n* Pushes execution of a function to end of execution queue, doing so\n* on next repaint\n* @return {Function}\n*/\nfunction queueExecution(fn) {\n    window.requestAnimationFrame(function () {\n        setTimeout(fn, 0);\n    });\n}\n\n/**\n* Returns the supported prefixed property - only `webkit` is needed, `moz`, `ms` and `o` are obsolete\n* @param {String} property\n* @return {String} - browser supported prefixed property\n*/\nfunction prefix(property) {\n    var prefixes = [false, 'webkit'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length; i++) {\n        var _prefix = prefixes[i];\n        var prefixedProp = _prefix ? '' + _prefix + upperProp : property;\n        if (typeof window.document.body.style[prefixedProp] !== 'undefined') {\n            return prefixedProp;\n        }\n    }\n\n    return null;\n}\n\n/**\n* Removes the title from the tooltipped element\n* @param {Element} el\n*/\nfunction removeTitle(el) {\n    var title = el.getAttribute('title');\n    el.setAttribute('data-original-title', title || 'html');\n    el.removeAttribute('title');\n}\n\n/**\n* Determines if an element is visible in the viewport\n* @param {Element} el\n* @return {Boolean}\n*/\nfunction elementIsInViewport(el) {\n    var rect = el.getBoundingClientRect();\n\n    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);\n}\n\n/**\n* Triggers a document repaint or reflow for CSS transition\n* @param {Element} tooltip\n* @param {Element} circle\n*/\nfunction triggerReflow(tooltip, circle) {\n    // Safari needs the specific 'transform' property to be accessed\n    circle ? window.getComputedStyle(circle)[prefix('transform')] : window.getComputedStyle(tooltip).opacity;\n}\n\n/**\n* Modifies elements' class lists\n* @param {Array} els - HTML elements\n* @param {Function} callback\n*/\nfunction modifyClassList(els, callback) {\n    els.forEach(function (el) {\n        if (!el) return;\n        callback(el.classList);\n    });\n}\n\n/**\n* Applies the transition duration to each element\n* @param {Array} els - HTML elements\n* @param {Number} duration\n*/\nfunction applyTransitionDuration(els, duration) {\n    var _duration = void 0;\n    els.forEach(function (el) {\n        if (!el) return;\n\n        _duration = duration;\n\n        if (el.hasAttribute('x-circle')) {\n            _duration = Math.round(duration / 1.1);\n        }\n\n        el.style[prefix('transitionDuration')] = _duration + 'ms';\n    });\n}\n\n/**\n* Determines if a popper is currently visible\n* @param {Element} popper\n* @return {Boolean}\n*/\nfunction isVisible(popper) {\n    return popper.style.visibility === 'visible';\n}\n\nfunction noop() {}\n\n/**\n* Returns the non-shifted placement (e.g., 'bottom-start' => 'bottom')\n* @param {String} placement\n* @return {String}\n*/\nfunction getCorePlacement(placement) {\n    return placement.replace(/-.+/, '');\n}\n\n/**\n* Mousemove event listener callback method for follow cursor setting\n* @param {MouseEvent} e\n*/\nfunction followCursorHandler(e) {\n    var _this = this;\n\n    var ref = find(Store, function (ref) {\n        return ref.el === _this;\n    });\n    var popper = ref.popper;\n\n\n    var position = getCorePlacement(popper.getAttribute('x-placement'));\n    var halfPopperWidth = Math.round(popper.offsetWidth / 2);\n    var halfPopperHeight = Math.round(popper.offsetHeight / 2);\n    var viewportPadding = 5;\n    var pageWidth = document.documentElement.offsetWidth || document.body.offsetWidth;\n\n    var pageX = e.pageX,\n        pageY = e.pageY;\n\n\n    var x = void 0,\n        y = void 0;\n\n    switch (position) {\n        case 'top':\n            x = pageX - halfPopperWidth;\n            y = pageY - 2.5 * halfPopperHeight;\n            break;\n        case 'left':\n            x = pageX - 2 * halfPopperWidth - 15;\n            y = pageY - halfPopperHeight;\n            break;\n        case 'right':\n            x = pageX + halfPopperHeight;\n            y = pageY - halfPopperHeight;\n            break;\n        case 'bottom':\n            x = pageX - halfPopperWidth;\n            y = pageY + halfPopperHeight / 1.5;\n            break;\n    }\n\n    var isRightOverflowing = pageX + viewportPadding + halfPopperWidth > pageWidth;\n    var isLeftOverflowing = pageX - viewportPadding - halfPopperWidth < 0;\n\n    // Prevent left/right overflow\n    if (position === 'top' || position === 'bottom') {\n        if (isRightOverflowing) {\n            x = pageWidth - viewportPadding - 2 * halfPopperWidth;\n        }\n\n        if (isLeftOverflowing) {\n            x = viewportPadding;\n        }\n    }\n\n    popper.style[prefix('transform')] = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n}\n\n/**\n* Returns an array of elements based on the selector input\n* @param {String|Element} selector\n* @return {Array} of HTML Elements\n*/\nfunction getArrayOfElementsFromSelector(selector) {\n    if (selector instanceof Element) {\n        return [selector];\n    }\n\n    return [].slice.call(document.querySelectorAll(selector));\n}\n\n/**\n* Prepares the callback functions for `show` and `hide` methods\n* @param {Object} ref -  the element/popper reference\n* @param {Number} duration\n* @param {Function} callback - callback function to fire once transitions complete\n*/\nfunction onTransitionEnd(ref, duration, callback) {\n\n    // Make callback synchronous if duration is 0\n    if (!duration) {\n        return callback();\n    }\n\n    var tooltip = ref.popper.querySelector(Selectors.TOOLTIP);\n    var transitionendFired = false;\n\n    var listenerCallback = function listenerCallback(e) {\n        if (e.target !== tooltip) return;\n\n        transitionendFired = true;\n\n        tooltip.removeEventListener('webkitTransitionEnd', listenerCallback);\n        tooltip.removeEventListener('transitionend', listenerCallback);\n\n        callback();\n    };\n\n    // Wait for transitions to complete\n    tooltip.addEventListener('webkitTransitionEnd', listenerCallback);\n    tooltip.addEventListener('transitionend', listenerCallback);\n\n    // transitionend listener sometimes may not fire\n    clearTimeout(ref._transitionendTimeout);\n    ref._transitionendTimeout = setTimeout(function () {\n        !transitionendFired && callback();\n    }, duration);\n}\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]'];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @method\n * @memberof Popper.Utils\n * @argument {Function | undefined} fn the function to check\n * @returns {Boolean}\n */\nvar isNative = function isNative(fn) {\n  return nativeHints.some(function (hint) {\n    return (fn || '').toString().indexOf(hint) > -1;\n  });\n};\n\nvar isBrowser = typeof window !== 'undefined';\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var scheduled = false;\n  var i = 0;\n  var elem = document.createElement('span');\n\n  // MutationObserver provides a mechanism for scheduling microtasks, which\n  // are scheduled *before* the next task. This gives us a way to debounce\n  // a function but ensure it's called *before* the next paint.\n  var observer = new MutationObserver(function () {\n    fn();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { attributes: true });\n\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      elem.setAttribute('x-index', i);\n      i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n    }\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nvar supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n    return window.document.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || element.firstElementChild.offsetParent === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  // NOTE: 1 DOM access here\n  var offsetParent = element && element.offsetParent;\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return window.document.documentElement;\n  }\n\n  return offsetParent;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return window.document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = window.document.documentElement;\n    var scrollingElement = window.document.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];\n}\n\n/**\n * Tells if you are running Internet Explorer 10\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean} isIE10\n */\nvar isIE10 = undefined;\n\nvar isIE10$1 = function isIE10$1() {\n  if (isIE10 === undefined) {\n    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n  }\n  return isIE10;\n};\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], html['client' + axis], html['offset' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = window.document.body;\n  var html = window.document.documentElement;\n  var computedStyle = isIE10$1() && window.getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  if (isIE10$1()) {\n    try {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } catch (err) {}\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var isIE10 = isIE10$1();\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top,\n    left: childrenRect.left - parentRect.left,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (isHTML || parent.nodeName === 'BODY') {\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = isIE10 && isHTML ? 0 : +styles.borderTopWidth.split('px')[0];\n    var borderLeftWidth = isIE10 && isHTML ? 0 : +styles.borderLeftWidth.split('px')[0];\n    var marginTop = isIE10 && isHTML ? 0 : +styles.marginTop.split('px')[0];\n    var marginLeft = isIE10 && isHTML ? 0 : +styles.marginLeft.split('px')[0];\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var html = window.document.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = getScroll(html);\n  var scrollLeft = getScroll(html, 'left');\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  // NOTE: 1 DOM access here\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(popper));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = window.document.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = window.document.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var commonOffsetParent = findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find$1(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find$1(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier.function) {\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier.function || modifier.fn;\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n  data.offsets.popper.position = 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length - 1; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof window.document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.left = '';\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? window : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  window.addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  window.removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    window.cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if the arrow style has been computed, apply the arrow style\n  if (data.offsets.arrow) {\n    setStyles(data.arrowElement, data.offsets.arrow);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // round sides to avoid blurry text\n  var offsets = {\n    left: Math.round(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.round(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update attributes and styles of `data`\n  data.attributes = attributes;\n  data.styles = _extends({}, styles, data.styles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find$1(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var side = isVertical ? 'top' : 'left';\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  var sideValue = center - getClientRect(data.offsets.popper)[side];\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = {};\n  data.offsets.arrow[side] = Math.round(sideValue);\n  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find$1(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, []\n    // Here we convert the string values into number values (in px)\n    ).map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find$1(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults$1 = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference.jquery ? reference[0] : reference;\n    this.popper = popper.jquery ? popper[0] : popper;\n\n    // make sure to apply the popper position before any computation\n    setStyles(this.popper, { position: 'absolute' });\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    }\n    // sort the modifiers by order\n    ).sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults$1;\n\n/**\n* Returns the distance taking into account the default distance due to\n* the transform: translate setting in CSS\n* @param {Number} distance\n* @return {String}\n*/\nfunction getOffsetDistanceInPx(distance) {\n    return -(distance - Defaults.distance) + 'px';\n}\n\nvar classCallCheck$1 = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass$1 = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends$1 = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n* Creates a new popper instance\n* @param {Object} ref\n* @return {Object} - the popper instance\n*/\nfunction createPopperInstance(ref) {\n    var el = ref.el,\n        popper = ref.popper,\n        _ref$settings = ref.settings,\n        position = _ref$settings.position,\n        popperOptions = _ref$settings.popperOptions,\n        offset = _ref$settings.offset,\n        distance = _ref$settings.distance;\n\n\n    var tooltip = popper.querySelector(Selectors.TOOLTIP);\n\n    var config = _extends$1({\n        placement: position\n    }, popperOptions || {}, {\n        modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {\n            flip: _extends$1({\n                padding: distance + 5 /* 5px from viewport boundary */\n            }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.flip : {}),\n            offset: _extends$1({\n                offset: offset\n            }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.offset : {})\n        }),\n        onUpdate: function onUpdate() {\n            tooltip.style.top = '';\n            tooltip.style.bottom = '';\n            tooltip.style.left = '';\n            tooltip.style.right = '';\n            tooltip.style[getCorePlacement(popper.getAttribute('x-placement'))] = getOffsetDistanceInPx(distance);\n        }\n    });\n\n    return new Popper(el, popper, config);\n}\n\n/**\n* Appends the popper and creates a popper instance if one does not exist\n* Also updates its position if need be and enables event listeners\n* @param {Object} ref -  the element/popper reference\n*/\nfunction mountPopper(ref) {\n    var el = ref.el,\n        popper = ref.popper,\n        _ref$settings = ref.settings,\n        appendTo = _ref$settings.appendTo,\n        followCursor = _ref$settings.followCursor;\n\n    // Already on the DOM\n\n    if (appendTo.contains(popper)) return;\n\n    appendTo.appendChild(popper);\n\n    if (!ref.popperInstance) {\n        // Create instance if it hasn't been created yet\n        ref.popperInstance = createPopperInstance(ref);\n    } else {\n        ref.popperInstance.update();\n\n        if (!followCursor || Browser.touch) {\n            ref.popperInstance.enableEventListeners();\n        }\n    }\n\n    // Since touch is determined dynamically, followCursor setting\n    // is set on mount\n    if (followCursor && !Browser.touch) {\n        el.addEventListener('mousemove', followCursorHandler);\n        ref.popperInstance.disableEventListeners();\n    }\n}\n\n/**\n* Updates a popper's position on each animation frame to make it stick to a moving element\n* @param {Object} ref\n*/\nfunction makeSticky(ref) {\n    var popper = ref.popper,\n        popperInstance = ref.popperInstance,\n        stickyDuration = ref.settings.stickyDuration;\n\n\n    var applyTransitionDuration = function applyTransitionDuration() {\n        return popper.style[prefix('transitionDuration')] = stickyDuration + 'ms';\n    };\n\n    var removeTransitionDuration = function removeTransitionDuration() {\n        return popper.style[prefix('transitionDuration')] = '';\n    };\n\n    var updatePosition = function updatePosition() {\n        popperInstance && popperInstance.scheduleUpdate();\n\n        applyTransitionDuration();\n\n        isVisible(popper) ? window.requestAnimationFrame(updatePosition) : removeTransitionDuration();\n    };\n\n    // Wait until Popper's position has been updated initially\n    queueExecution(updatePosition);\n}\n\n/**\n* Returns an object of settings to override global settings\n* @param {Element} el - the tooltipped element\n* @param {Object} instanceSettings\n* @return {Object} - individual settings\n*/\nfunction getIndividualSettings(el, instanceSettings) {\n\n    var settings = DefaultsKeys.reduce(function (acc, key) {\n        var val = el.getAttribute('data-' + key.toLowerCase()) || instanceSettings[key];\n\n        // Convert strings to booleans\n        if (val === 'false') val = false;\n        if (val === 'true') val = true;\n\n        // Convert number strings to true numbers\n        if (isFinite(val) && !isNaN(parseFloat(val))) {\n            val = parseFloat(val);\n        }\n\n        // Convert array strings to actual arrays\n        if (typeof val === 'string' && val.trim().charAt(0) === '[') {\n            val = JSON.parse(val);\n        }\n\n        acc[key] = val;\n\n        return acc;\n    }, {});\n\n    return _extends$1({}, instanceSettings, settings);\n}\n\n/**\n* Creates a popper element then returns it\n* @param {Number} id - the popper id\n* @param {String} title - the tooltip's `title` attribute\n* @param {Object} settings - individual settings\n* @return {Element} - the popper element\n*/\nfunction createPopperElement(id, title, settings) {\n    var position = settings.position,\n        distance = settings.distance,\n        arrow = settings.arrow,\n        animateFill = settings.animateFill,\n        inertia = settings.inertia,\n        animation = settings.animation,\n        arrowSize = settings.arrowSize,\n        size = settings.size,\n        theme = settings.theme,\n        html = settings.html,\n        zIndex = settings.zIndex,\n        interactive = settings.interactive;\n\n\n    var popper = document.createElement('div');\n    popper.setAttribute('class', 'tippy-popper');\n    popper.setAttribute('role', 'tooltip');\n    popper.setAttribute('aria-hidden', 'true');\n    popper.setAttribute('id', 'tippy-tooltip-' + id);\n    popper.style.zIndex = zIndex;\n\n    var tooltip = document.createElement('div');\n    tooltip.setAttribute('class', 'tippy-tooltip tippy-tooltip--' + size + ' leave');\n    tooltip.setAttribute('data-animation', animation);\n\n    theme.split(' ').forEach(function (t) {\n        tooltip.classList.add(t + '-theme');\n    });\n\n    if (arrow) {\n        // Add an arrow\n        var _arrow = document.createElement('div');\n        _arrow.setAttribute('class', 'arrow-' + arrowSize);\n        _arrow.setAttribute('x-arrow', '');\n        tooltip.appendChild(_arrow);\n    }\n\n    if (animateFill) {\n        // Create animateFill circle element for animation\n        tooltip.setAttribute('data-animatefill', '');\n        var circle = document.createElement('div');\n        circle.setAttribute('class', 'leave');\n        circle.setAttribute('x-circle', '');\n        tooltip.appendChild(circle);\n    }\n\n    if (inertia) {\n        // Change transition timing function cubic bezier\n        tooltip.setAttribute('data-inertia', '');\n    }\n\n    if (interactive) {\n        tooltip.setAttribute('data-interactive', '');\n    }\n\n    // Tooltip content (text or HTML)\n    var content = document.createElement('div');\n    content.setAttribute('class', 'tippy-tooltip-content');\n\n    if (html) {\n\n        var templateId = void 0;\n\n        if (html instanceof Element) {\n            content.appendChild(html);\n            templateId = html.id || 'tippy-html-template';\n        } else {\n            content.innerHTML = document.getElementById(html.replace('#', '')).innerHTML;\n            templateId = html;\n        }\n\n        popper.classList.add('html-template');\n        popper.setAttribute('tabindex', '0');\n        tooltip.setAttribute('data-template-id', templateId);\n    } else {\n        content.innerHTML = title;\n    }\n\n    // Init distance. Further updates are made in the popper instance's `onUpdate()` method\n    tooltip.style[getCorePlacement(position)] = getOffsetDistanceInPx(distance);\n\n    tooltip.appendChild(content);\n    popper.appendChild(tooltip);\n\n    return popper;\n}\n\n/**\n* Creates a trigger\n* @param {Object} event - the custom event specified in the `trigger` setting\n* @param {Element} el - tooltipped element\n* @param {Object} handlers - the handlers for each listener\n* @return {Array} - array of listener objects\n*/\nfunction createTrigger(event, el, handlers, touchHold) {\n    var listeners = [];\n\n    if (event === 'manual') return listeners;\n\n    // Enter\n    el.addEventListener(event, handlers.handleTrigger);\n    listeners.push({\n        event: event,\n        handler: handlers.handleTrigger\n    });\n\n    // Leave\n    if (event === 'mouseenter') {\n\n        if (Browser.SUPPORTS_TOUCH && touchHold) {\n            el.addEventListener('touchstart', handlers.handleTrigger);\n            listeners.push({\n                event: 'touchstart',\n                handler: handlers.handleTrigger\n            });\n            el.addEventListener('touchend', handlers.handleMouseleave);\n            listeners.push({\n                event: 'touchend',\n                handler: handlers.handleMouseleave\n            });\n        }\n\n        el.addEventListener('mouseleave', handlers.handleMouseleave);\n        listeners.push({\n            event: 'mouseleave',\n            handler: handlers.handleMouseleave\n        });\n    }\n\n    if (event === 'focus') {\n        el.addEventListener('blur', handlers.handleBlur);\n        listeners.push({\n            event: 'blur',\n            handler: handlers.handleBlur\n        });\n    }\n\n    return listeners;\n}\n\n/**\n* Determines if the mouse's cursor is outside the interactive border\n* @param {MouseEvent} event\n* @param {Element} popper\n* @param {Object} settings\n* @return {Boolean}\n*/\nfunction cursorIsOutsideInteractiveBorder(event, popper, settings) {\n    if (!popper.getAttribute('x-placement')) return true;\n\n    var x = event.clientX,\n        y = event.clientY;\n    var interactiveBorder = settings.interactiveBorder,\n        distance = settings.distance;\n\n\n    var rect = popper.getBoundingClientRect();\n    var corePosition = getCorePlacement(popper.getAttribute('x-placement'));\n    var borderWithDistance = interactiveBorder + distance;\n\n    var exceeds = {\n        top: rect.top - y > interactiveBorder,\n        bottom: y - rect.bottom > interactiveBorder,\n        left: rect.left - x > interactiveBorder,\n        right: x - rect.right > interactiveBorder\n    };\n\n    switch (corePosition) {\n        case 'top':\n            exceeds.top = rect.top - y > borderWithDistance;\n            break;\n        case 'bottom':\n            exceeds.bottom = y - rect.bottom > borderWithDistance;\n            break;\n        case 'left':\n            exceeds.left = rect.left - x > borderWithDistance;\n            break;\n        case 'right':\n            exceeds.right = x - rect.right > borderWithDistance;\n            break;\n    }\n\n    return exceeds.top || exceeds.bottom || exceeds.left || exceeds.right;\n}\n\n/**\n* Returns relevant listener callbacks for each ref\n* @param {Element} el\n* @param {Element} popper\n* @param {Object} settings\n* @return {Object} - relevant listener callback methods\n*/\nfunction getEventListenerHandlers(el, popper, settings) {\n    var _this = this;\n\n    var position = settings.position,\n        delay = settings.delay,\n        duration = settings.duration,\n        interactive = settings.interactive,\n        interactiveBorder = settings.interactiveBorder,\n        distance = settings.distance,\n        hideOnClick = settings.hideOnClick,\n        trigger = settings.trigger,\n        touchHold = settings.touchHold,\n        touchWait = settings.touchWait;\n\n\n    var showDelay = void 0,\n        hideDelay = void 0;\n\n    var clearTimeouts = function clearTimeouts() {\n        clearTimeout(showDelay);\n        clearTimeout(hideDelay);\n    };\n\n    var _show = function _show() {\n        clearTimeouts();\n\n        // Not hidden. For clicking when it also has a `focus` event listener\n        if (isVisible(popper)) return;\n\n        var _delay = Array.isArray(delay) ? delay[0] : delay;\n\n        if (delay) {\n            showDelay = setTimeout(function () {\n                return _this.show(popper);\n            }, _delay);\n        } else {\n            _this.show(popper);\n        }\n    };\n\n    var show = function show(event) {\n        return _this.callbacks.wait ? _this.callbacks.wait.call(popper, _show, event) : _show();\n    };\n\n    var hide = function hide() {\n        clearTimeouts();\n\n        var _delay = Array.isArray(delay) ? delay[1] : delay;\n\n        if (delay) {\n            hideDelay = setTimeout(function () {\n                return _this.hide(popper);\n            }, _delay);\n        } else {\n            _this.hide(popper);\n        }\n    };\n\n    var handleTrigger = function handleTrigger(event) {\n\n        if (event.type === 'mouseenter' && Browser.SUPPORTS_TOUCH && Browser.touch) {\n            if (touchHold) return;\n            if (Browser.iOS()) el.click();\n        }\n\n        // Toggle show/hide when clicking click-triggered tooltips\n        var isClick = event.type === 'click';\n        var isNotPersistent = hideOnClick !== 'persistent';\n\n        isClick && isVisible(popper) && isNotPersistent ? hide() : show(event);\n    };\n\n    var handleMouseleave = function handleMouseleave(event) {\n\n        // Don't fire 'mouseleave', use the 'touchend'\n        if (event.type === 'mouseleave' && Browser.SUPPORTS_TOUCH && Browser.touch && touchHold) {\n            return;\n        }\n\n        if (interactive) {\n            // Temporarily handle mousemove to check if the mouse left somewhere\n            // other than its popper\n            var handleMousemove = function handleMousemove(event) {\n\n                var triggerHide = function triggerHide() {\n                    document.body.removeEventListener('mouseleave', hide);\n                    document.removeEventListener('mousemove', handleMousemove);\n                    hide();\n                };\n\n                var closestTooltippedEl = closest(event.target, Selectors.TOOLTIPPED_EL);\n\n                var isOverPopper = closest(event.target, Selectors.POPPER) === popper;\n                var isOverEl = closestTooltippedEl === el;\n                var isClickTriggered = trigger.indexOf('click') !== -1;\n                var isOverOtherTooltippedEl = closestTooltippedEl && closestTooltippedEl !== el;\n\n                if (isOverOtherTooltippedEl) {\n                    return triggerHide();\n                }\n\n                if (isOverPopper || isOverEl || isClickTriggered) return;\n\n                if (cursorIsOutsideInteractiveBorder(event, popper, settings)) {\n                    triggerHide();\n                }\n            };\n\n            document.body.addEventListener('mouseleave', hide);\n            document.addEventListener('mousemove', handleMousemove);\n\n            return;\n        }\n\n        // If it's not interactive, just hide it\n        hide();\n    };\n\n    var handleBlur = function handleBlur(event) {\n        // Ignore blur on touch devices, if there is no `relatedTarget`, hide\n        // If the related target is a popper, ignore\n        if (Browser.touch || !event.relatedTarget) return;\n        if (closest(event.relatedTarget, Selectors.POPPER)) return;\n\n        hide();\n    };\n\n    return {\n        handleTrigger: handleTrigger,\n        handleMouseleave: handleMouseleave,\n        handleBlur: handleBlur\n    };\n}\n\nvar idCounter = 1;\n\n/**\n* Creates tooltips for all el elements that match the instance's selector\n* @param {Array} els - Elements\n*/\nfunction createTooltips(els) {\n    var _this = this;\n\n    els.forEach(function (el) {\n\n        var settings = _this.settings.performance ? _this.settings : getIndividualSettings(el, _this.settings);\n\n        // animateFill is disabled if an arrow is true\n        if (settings.arrow) settings.animateFill = false;\n\n        var html = settings.html,\n            trigger = settings.trigger,\n            touchHold = settings.touchHold;\n\n\n        var title = el.getAttribute('title');\n        if (!title && !html) return;\n\n        var id = idCounter;\n        el.setAttribute('data-tooltipped', '');\n        el.setAttribute('aria-describedby', 'tippy-tooltip-' + id);\n\n        removeTitle(el);\n\n        var popper = createPopperElement(id, title, settings);\n        var handlers = getEventListenerHandlers.call(_this, el, popper, settings);\n        var listeners = [];\n\n        trigger.trim().split(' ').forEach(function (event) {\n            return listeners = listeners.concat(createTrigger(event, el, handlers, touchHold));\n        });\n\n        Store.push({\n            id: id,\n            el: el,\n            popper: popper,\n            settings: settings,\n            listeners: listeners,\n            tippyInstance: _this\n        });\n\n        idCounter++;\n    });\n}\n\n/* Utility functions */\n/* Core library functions */\n/**\n* @param {String|Element} selector\n* @param {Object} settings (optional) - the object of settings to be applied to the instance\n*/\n\nvar Tippy = function () {\n    function Tippy(selector) {\n        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        classCallCheck$1(this, Tippy);\n\n\n        // Use default browser tooltip on unsupported browsers\n        if (!Browser.SUPPORTED) return;\n\n        // DOM is presumably mostly ready (for document.body) by instantiation time\n        init();\n\n        this.state = {\n            destroyed: false\n        };\n\n        this.selector = selector;\n\n        this.settings = _extends$1({}, Defaults, settings);\n\n        this.callbacks = {\n            wait: settings.wait,\n            show: settings.show || noop,\n            shown: settings.shown || noop,\n            hide: settings.hide || noop,\n            hidden: settings.hidden || noop\n        };\n\n        createTooltips.call(this, getArrayOfElementsFromSelector(selector));\n    }\n\n    /**\n    * Returns the reference element's popper element\n    * @param {Element} el\n    * @return {Element}\n    */\n\n\n    createClass$1(Tippy, [{\n        key: 'getPopperElement',\n        value: function getPopperElement(el) {\n            var _this = this;\n\n            try {\n                return find(Store.filter(function (ref) {\n                    return ref.tippyInstance === _this;\n                }), function (ref) {\n                    return ref.el === el;\n                }).popper;\n            } catch (e) {\n                console.error('[getPopperElement]: Element passed as the argument does not exist in the instance');\n            }\n        }\n\n        /**\n        * Returns a popper's element reference\n        * @param {Element} popper\n        * @return {Element}\n        */\n\n    }, {\n        key: 'getReferenceElement',\n        value: function getReferenceElement(popper) {\n            var _this2 = this;\n\n            try {\n                return find(Store.filter(function (ref) {\n                    return ref.tippyInstance === _this2;\n                }), function (ref) {\n                    return ref.popper === popper;\n                }).el;\n            } catch (e) {\n                console.error('[getReferenceElement]: Popper passed as the argument does not exist in the instance');\n            }\n        }\n\n        /**\n        * Returns the reference data object from either the reference element or popper element\n        * @param {Element} x (reference element or popper)\n        * @return {Object}\n        */\n\n    }, {\n        key: 'getReferenceData',\n        value: function getReferenceData(x) {\n            return find(Store, function (ref) {\n                return ref.el === x || ref.popper === x;\n            });\n        }\n\n        /**\n        * Shows a popper\n        * @param {Element} popper\n        * @param {Number} customDuration (optional)\n        * @param {Boolean} _makeSync internal param for testing, makes it synchronous\n        */\n\n    }, {\n        key: 'show',\n        value: function show(popper, customDuration, _makeSync) {\n            var _this3 = this;\n\n            if (this.state.destroyed) return;\n\n            this.callbacks.show.call(popper);\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var tooltip = popper.querySelector(Selectors.TOOLTIP);\n            var circle = popper.querySelector(Selectors.CIRCLE);\n\n            var el = ref.el,\n                _ref$settings = ref.settings,\n                appendTo = _ref$settings.appendTo,\n                sticky = _ref$settings.sticky,\n                interactive = _ref$settings.interactive,\n                followCursor = _ref$settings.followCursor,\n                flipDuration = _ref$settings.flipDuration,\n                duration = _ref$settings.duration;\n\n\n            var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[0] : duration;\n\n            // Remove transition duration (prevent a transition when popper changes posiiton)\n            applyTransitionDuration([popper, tooltip, circle], 0);\n\n            mountPopper(ref);\n\n            popper.style.visibility = 'visible';\n            popper.setAttribute('aria-hidden', 'false');\n\n            // Wait for popper to update position and alter x-placement\n            queueExecution(function () {\n                if (!isVisible(popper)) return;\n\n                // Sometimes the arrow will not be in the correct position,\n                // force another update\n                if (!followCursor || Browser.touch) {\n                    ref.popperInstance.update();\n                }\n\n                // Re-apply transition durations\n                applyTransitionDuration([tooltip, circle], _duration, true);\n                if (!followCursor || Browser.touch) {\n                    applyTransitionDuration([popper], flipDuration, true);\n                }\n\n                // Interactive tooltips receive a class of 'active'\n                interactive && el.classList.add('active');\n\n                // Update popper's position on every animation frame\n                sticky && makeSticky(ref);\n\n                // Repaint/reflow is required for CSS transition when appending\n                triggerReflow(tooltip, circle);\n\n                modifyClassList([tooltip, circle], function (list) {\n                    list.contains('tippy-notransition') && list.remove('tippy-notransition');\n                    list.remove('leave');\n                    list.add('enter');\n                });\n\n                // Wait for transitions to complete\n                onTransitionEnd(ref, _duration, function () {\n                    if (!isVisible(popper) || ref._onShownFired) return;\n\n                    // Focus interactive tooltips only\n                    interactive && popper.focus();\n\n                    // Remove transitions from tooltip\n                    tooltip.classList.add('tippy-notransition');\n\n                    // Prevents shown() from firing more than once from early transition cancellations\n                    ref._onShownFired = true;\n\n                    _this3.callbacks.shown.call(popper);\n                });\n            });\n        }\n\n        /**\n        * Hides a popper\n        * @param {Element} popper\n        * @param {Number} customDuration (optional)\n        */\n\n    }, {\n        key: 'hide',\n        value: function hide(popper, customDuration) {\n            var _this4 = this;\n\n            if (this.state.destroyed) return;\n\n            this.callbacks.hide.call(popper);\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var tooltip = popper.querySelector(Selectors.TOOLTIP);\n            var circle = popper.querySelector(Selectors.CIRCLE);\n            var content = popper.querySelector(Selectors.CONTENT);\n\n            var el = ref.el,\n                _ref$settings2 = ref.settings,\n                appendTo = _ref$settings2.appendTo,\n                sticky = _ref$settings2.sticky,\n                interactive = _ref$settings2.interactive,\n                followCursor = _ref$settings2.followCursor,\n                html = _ref$settings2.html,\n                trigger = _ref$settings2.trigger,\n                duration = _ref$settings2.duration;\n\n\n            var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[1] : duration;\n\n            ref._onShownFired = false;\n            interactive && el.classList.remove('active');\n\n            popper.style.visibility = 'hidden';\n            popper.setAttribute('aria-hidden', 'true');\n\n            applyTransitionDuration([tooltip, circle], _duration);\n\n            modifyClassList([tooltip, circle], function (list) {\n                list.contains('tippy-tooltip') && list.remove('tippy-notransition');\n                list.remove('enter');\n                list.add('leave');\n            });\n\n            // Re-focus click-triggered html elements\n            // and the tooltipped element IS in the viewport (otherwise it causes unsightly scrolling\n            // if the tooltip is closed and the element isn't in the viewport anymore)\n            if (html && trigger.indexOf('click') !== -1 && elementIsInViewport(el)) {\n                el.focus();\n            }\n\n            // Wait for transitions to complete\n            onTransitionEnd(ref, _duration, function () {\n                if (isVisible(popper) || !appendTo.contains(popper)) return;\n\n                el.removeEventListener('mousemove', followCursorHandler);\n                ref.popperInstance.disableEventListeners();\n\n                appendTo.removeChild(popper);\n\n                _this4.callbacks.hidden.call(popper);\n            });\n        }\n\n        /**\n        * Destroys a popper\n        * @param {Element} popper\n        */\n\n    }, {\n        key: 'destroy',\n        value: function destroy(popper) {\n            if (this.state.destroyed) return;\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var el = ref.el,\n                popperInstance = ref.popperInstance,\n                listeners = ref.listeners;\n\n            // Ensure the popper is hidden\n\n            if (isVisible(popper)) {\n                this.hide(popper, 0);\n            }\n\n            // Remove Tippy-only event listeners from tooltipped element\n            listeners.forEach(function (listener) {\n                return el.removeEventListener(listener.event, listener.handler);\n            });\n\n            // ReStore original title\n            el.setAttribute('title', el.getAttribute('data-original-title'));\n\n            el.removeAttribute('data-original-title');\n            el.removeAttribute('data-tooltipped');\n            el.removeAttribute('aria-describedby');\n\n            popperInstance && popperInstance.destroy();\n\n            // Remove from storage\n            Store.splice(Store.map(function (ref) {\n                return ref.popper;\n            }).indexOf(popper), 1);\n        }\n\n        /**\n        * Updates a popper with new content\n        * @param {Element} popper\n        */\n\n    }, {\n        key: 'update',\n        value: function update(popper) {\n            if (this.state.destroyed) return;\n\n            var ref = find(Store, function (ref) {\n                return ref.popper === popper;\n            });\n            var content = popper.querySelector(Selectors.CONTENT);\n            var el = ref.el,\n                html = ref.settings.html;\n\n\n            if (html) {\n                content.innerHTML = html instanceof Element ? html.innerHTML : document.getElementById(html.replace('#', '')).innerHTML;\n            } else {\n                content.innerHTML = el.getAttribute('title') || el.getAttribute('data-original-title');\n                removeTitle(el);\n            }\n        }\n    }, {\n        key: 'destroyAll',\n        value: function destroyAll() {\n            var _this5 = this;\n\n            if (this.state.destroyed) return;\n\n            Store.filter(function (ref) {\n                return ref.tippyInstance === _this5;\n            }).forEach(function (ref) {\n                _this5.destroy(ref.popper);\n            });\n\n            this.state.destroyed = true;\n        }\n    }]);\n    return Tippy;\n}();\n\nfunction tippy$2(selector, settings) {\n    return new Tippy(selector, settings);\n}\n\ntippy$2.Browser = Browser;\ntippy$2.Defaults = Defaults;\ntippy$2.disableDynamicInputDetection = function () {\n    return Browser.dynamicInputDetection = false;\n};\ntippy$2.enableDynamicInputDetection = function () {\n    return Browser.dynamicInputDetection = true;\n};\n\nreturn tippy$2;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tippy.js/dist/tippy.js\n// module id = 9\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 10\n// module chunks = 0"],"sourceRoot":""}